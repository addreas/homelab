// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/VictoriaMetrics/operator/api/v1beta1

package v1beta1

import (
	"k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	appsv1 "k8s.io/api/apps/v1"
)

// VMAgentSpec defines the desired state of VMAgent
// +k8s:openapi-gen=true
// +kubebuilder:printcolumn:name="Version",type="string",JSONPath=".spec.version",description="The version of VMAgent"
// +kubebuilder:printcolumn:name="ReplicaCount",type="integer",JSONPath=".spec.replicas",description="The desired replicas number of VMAgent"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
#VMAgentSpec: {
	// PodMetadata configures Labels and Annotations which are propagated to the vmagent pods.
	// +optional
	podMetadata?: null | #EmbeddedObjectMetadata @go(PodMetadata,*EmbeddedObjectMetadata)

	// Image - docker image settings for VMAgent
	// if no specified operator uses default config version
	// +optional
	image?: #Image @go(Image)

	// ImagePullSecrets An optional list of references to secrets in the same namespace
	// to use for pulling images from registries
	// see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
	// +optional
	imagePullSecrets?: [...v1.#LocalObjectReference] @go(ImagePullSecrets,[]v1.LocalObjectReference)

	// Secrets is a list of Secrets in the same namespace as the vmagent
	// object, which shall be mounted into the vmagent Pods.
	// will be mounted at path /etc/vm/secrets
	// +optional
	secrets?: [...string] @go(Secrets,[]string)

	// ConfigMaps is a list of ConfigMaps in the same namespace as the vmagent
	// object, which shall be mounted into the vmagent Pods.
	// will be mounted at path  /etc/vm/configs
	// +optional
	configMaps?: [...string] @go(ConfigMaps,[]string)

	// LogLevel for VMAgent to be configured with.
	//INFO, WARN, ERROR, FATAL, PANIC
	// +optional
	// +kubebuilder:validation:Enum=INFO;WARN;ERROR;FATAL;PANIC
	logLevel?: string @go(LogLevel)

	// LogFormat for VMAgent to be configured with.
	// +optional
	// +kubebuilder:validation:Enum=default;json
	logFormat?: string @go(LogFormat)

	// ReplicaCount is the expected size of the VMAgent cluster. The controller will
	// eventually make the size of the running cluster equal to the expected
	// size.
	// NOTE enable VMSingle deduplication for replica usage
	// +operator-sdk:csv:customresourcedefinitions:type=spec,displayName="Number of pods",xDescriptors="urn:alm:descriptor:com.tectonic.ui:podCount,urn:alm:descriptor:io.kubernetes:custom"
	// +optional
	replicaCount?: null | int32 @go(ReplicaCount,*int32)

	// Volumes allows configuration of additional volumes on the output deploy definition.
	// Volumes specified will be appended to other volumes that are generated as a result of
	// StorageSpec objects.
	// +optional
	volumes?: [...v1.#Volume] @go(Volumes,[]v1.Volume)

	// VolumeMounts allows configuration of additional VolumeMounts on the output deploy definition.
	// VolumeMounts specified will be appended to other VolumeMounts in the vmagent container,
	// that are generated as a result of StorageSpec objects.
	// +optional
	volumeMounts?: [...v1.#VolumeMount] @go(VolumeMounts,[]v1.VolumeMount)

	// Resources container resource request and limits, https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
	//if not specified - default setting will be used
	// +operator-sdk:csv:customresourcedefinitions:type=spec,displayName="Resources",xDescriptors="urn:alm:descriptor:com.tectonic.ui:resourceRequirements"
	// +optional
	resources?: v1.#ResourceRequirements @go(Resources)

	// Affinity If specified, the pod's scheduling constraints.
	// +optional
	affinity?: null | v1.#Affinity @go(Affinity,*v1.Affinity)

	// Tolerations If specified, the pod's tolerations.
	// +optional
	tolerations?: [...v1.#Toleration] @go(Tolerations,[]v1.Toleration)

	// SecurityContext holds pod-level security attributes and common container settings.
	// This defaults to the default PodSecurityContext.
	// +optional
	securityContext?: null | v1.#PodSecurityContext @go(SecurityContext,*v1.PodSecurityContext)

	// ServiceAccountName is the name of the ServiceAccount to use to run the
	// VMAgent Pods.
	// +optional
	// +operator-sdk:csv:customresourcedefinitions:type=spec,displayName="ServiceAccount name",xDescriptors="urn:alm:descriptor:io.kubernetes:ServiceAccount"
	serviceAccountName?: string @go(ServiceAccountName)

	// SchedulerName - defines kubernetes scheduler name
	// +optional
	schedulerName?: string @go(SchedulerName)

	// RuntimeClassName - defines runtime class for kubernetes pod.
	//https://kubernetes.io/docs/concepts/containers/runtime-class/
	runtimeClassName?: null | string @go(RuntimeClassName,*string)

	// HostAliases provides mapping between ip and hostnames,
	// that would be propagated to pod,
	// cannot be used with HostNetwork.
	// +optional
	host_aliases?: [...v1.#HostAlias] @go(HostAliases,[]v1.HostAlias)

	// PodSecurityPolicyName - defines name for podSecurityPolicy
	// in case of empty value, prefixedName will be used.
	// +optional
	podSecurityPolicyName?: string @go(PodSecurityPolicyName)

	// Containers property allows to inject additions sidecars or to patch existing containers.
	// It can be useful for proxies, backup, etc.
	// +optional
	containers?: [...v1.#Container] @go(Containers,[]v1.Container)

	// InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
	// fetch secrets for injection into the vmagent configuration from external sources. Any
	// errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// Using initContainers for any use case other then secret fetching is entirely outside the scope
	// of what the maintainers will support and by doing so, you accept that this behaviour may break
	// at any time without notice.
	// +optional
	initContainers?: [...v1.#Container] @go(InitContainers,[]v1.Container)

	// PriorityClassName assigned to the Pods
	// +optional
	priorityClassName?: string @go(PriorityClassName)

	// HostNetwork controls whether the pod may use the node network namespace
	// +optional
	hostNetwork?: bool @go(HostNetwork)

	// DNSPolicy set DNS policy for the pod
	// +optional
	dnsPolicy?: v1.#DNSPolicy @go(DNSPolicy)

	// TopologySpreadConstraints embedded kubernetes pod configuration option,
	// controls how pods are spread across your cluster among failure-domains
	// such as regions, zones, nodes, and other user-defined topology domains
	// https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
	// +optional
	topologySpreadConstraints?: [...v1.#TopologySpreadConstraint] @go(TopologySpreadConstraints,[]v1.TopologySpreadConstraint)

	// ScrapeInterval defines how often scrape targets by default
	// +optional
	// +kubebuilder:validation:Pattern:="[0-9]+(ms|s|m|h)"
	scrapeInterval?: string @go(ScrapeInterval)

	// APIServerConfig allows specifying a host and auth methods to access apiserver.
	// If left empty, VMAgent is assumed to run inside of the cluster
	// and will discover API servers automatically and use the pod's CA certificate
	// and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
	// +optional
	aPIServerConfig?: null | #APIServerConfig @go(APIServerConfig,*APIServerConfig)

	// OverrideHonorLabels if set to true overrides all user configured honor_labels.
	// If HonorLabels is set in ServiceScrape or PodScrape to true, this overrides honor_labels to false.
	// +optional
	overrideHonorLabels?: bool @go(OverrideHonorLabels)

	// OverrideHonorTimestamps allows to globally enforce honoring timestamps in all scrape configs.
	// +optional
	overrideHonorTimestamps?: bool @go(OverrideHonorTimestamps)

	// IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector settings from
	// the podscrape and vmservicescrape configs, and they will only discover endpoints
	// within their current namespace.  Defaults to false.
	// +optional
	ignoreNamespaceSelectors?: bool @go(IgnoreNamespaceSelectors)

	// EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
	// and metric that is user created. The label value will always be the namespace of the object that is
	// being created.
	// +optional
	enforcedNamespaceLabel?: string @go(EnforcedNamespaceLabel)

	// VMAgentExternalLabelName Name of vmAgent external label used to denote vmAgent instance
	// name. Defaults to the value of `prometheus`. External label will
	// _not_ be added when value is set to empty string (`""`).
	// +optional
	vmAgentExternalLabelName?: null | string @go(VMAgentExternalLabelName,*string)

	// ExternalLabels The labels to add to any time series or alerts when communicating with
	// external systems (federation, remote storage, etc).
	// +optional
	externalLabels?: {[string]: string} @go(ExternalLabels,map[string]string)

	// RemoteWrite list of victoria metrics /some other remote write system
	// for vm it must looks like: http://victoria-metrics-single:8429/api/v1/write
	// or for cluster different url
	// https://github.com/VictoriaMetrics/VictoriaMetrics/tree/master/app/vmagent#splitting-data-streams-among-multiple-systems
	// +optional
	remoteWrite: [...#VMAgentRemoteWriteSpec] @go(RemoteWrite,[]VMAgentRemoteWriteSpec)

	// RemoteWriteSettings defines global settings for all remoteWrite urls.
	// + optional
	remoteWriteSettings?: null | #VMAgentRemoteWriteSettings @go(RemoteWriteSettings,*VMAgentRemoteWriteSettings)

	// RelabelConfig ConfigMap with global relabel config -remoteWrite.relabelConfig
	// This relabeling is applied to all the collected metrics before sending them to remote storage.
	// +optional
	// +operator-sdk:csv:customresourcedefinitions:type=spec,displayName="Key at Configmap with relabelConfig name",xDescriptors="urn:alm:descriptor:io.kubernetes:ConfigMapKeySelector"
	relabelConfig?: null | v1.#ConfigMapKeySelector @go(RelabelConfig,*v1.ConfigMapKeySelector)

	// InlineRelabelConfig - defines GlobalRelabelConfig for vmagent, can be defined directly at CRD.
	// +optional
	inlineRelabelConfig?: [...#RelabelConfig] @go(InlineRelabelConfig,[]RelabelConfig)

	// ServiceScrapeSelector defines ServiceScrapes to be selected for target discovery.
	// +optional
	serviceScrapeSelector?: null | metav1.#LabelSelector @go(ServiceScrapeSelector,*metav1.LabelSelector)

	// ServiceScrapeNamespaceSelector Namespaces to be selected for VMServiceScrape discovery. If nil, only
	// check own namespace.
	// +optional
	serviceScrapeNamespaceSelector?: null | metav1.#LabelSelector @go(ServiceScrapeNamespaceSelector,*metav1.LabelSelector)

	// PodScrapeSelector defines PodScrapes to be selected for target discovery.
	// +optional
	podScrapeSelector?: null | metav1.#LabelSelector @go(PodScrapeSelector,*metav1.LabelSelector)

	// PodScrapeNamespaceSelector defines Namespaces to be selected for VMPodScrape discovery. If nil, only
	// check own namespace.
	// +optional
	podScrapeNamespaceSelector?: null | metav1.#LabelSelector @go(PodScrapeNamespaceSelector,*metav1.LabelSelector)

	// ProbeSelector defines VMProbe to be selected for target probing.
	// +optional
	probeSelector?: null | metav1.#LabelSelector @go(ProbeSelector,*metav1.LabelSelector)

	// ProbeNamespaceSelector defines Namespaces to be selected for VMProbe discovery. If nil, only
	// check own namespace.
	// +optional
	probeNamespaceSelector?: null | metav1.#LabelSelector @go(ProbeNamespaceSelector,*metav1.LabelSelector)

	// NodeScrapeSelector defines VMNodeScrape to be selected for scraping.
	// +optional
	nodeScrapeSelector?: null | metav1.#LabelSelector @go(NodeScrapeSelector,*metav1.LabelSelector)

	// NodeScrapeNamespaceSelector defines Namespaces to be selected for VMNodeScrape discovery. If nil, only
	// check own namespace.
	// +optional
	nodeScrapeNamespaceSelector?: null | metav1.#LabelSelector @go(NodeScrapeNamespaceSelector,*metav1.LabelSelector)

	// StaticScrapeSelector defines PodScrapes to be selected for target discovery.
	// +optional
	staticScrapeSelector?: null | metav1.#LabelSelector @go(StaticScrapeSelector,*metav1.LabelSelector)

	// StaticScrapeNamespaceSelector defines Namespaces to be selected for VMStaticScrape discovery. If nil, only
	// check own namespace.
	// +optional
	staticScrapeNamespaceSelector?: null | metav1.#LabelSelector @go(StaticScrapeNamespaceSelector,*metav1.LabelSelector)

	// InlineScrapeConfig As scrape configs are appended, the user is responsible to make sure it
	// is valid. Note that using this feature may expose the possibility to
	// break upgrades of VMAgent. It is advised to review VMAgent release
	// notes to ensure that no incompatible scrape configs are going to break
	// VMAgent after the upgrade.
	// it should be defined as single yaml file.
	// inlineScrapeConfig: |
	//     - job_name: "prometheus"
	//       static_configs:
	//       - targets: ["localhost:9090"]
	// +optional
	inlineScrapeConfig?: string @go(InlineScrapeConfig)

	// AdditionalScrapeConfigs As scrape configs are appended, the user is responsible to make sure it
	// is valid. Note that using this feature may expose the possibility to
	// break upgrades of VMAgent. It is advised to review VMAgent release
	// notes to ensure that no incompatible scrape configs are going to break
	// VMAgent after the upgrade.
	// +optional
	additionalScrapeConfigs?: null | v1.#SecretKeySelector @go(AdditionalScrapeConfigs,*v1.SecretKeySelector)

	// ArbitraryFSAccessThroughSMs configures whether configuration
	// based on a service scrape can access arbitrary files on the file system
	// of the VMAgent container e.g. bearer token files.
	// +optional
	arbitraryFSAccessThroughSMs?: #ArbitraryFSAccessThroughSMsConfig @go(ArbitraryFSAccessThroughSMs)

	// InsertPorts - additional listen ports for data ingestion.
	insertPorts?: null | #InsertPorts @go(InsertPorts,*InsertPorts)

	// Port listen address
	// +optional
	port?: string @go(Port)

	// ExtraArgs that will be passed to  VMAgent pod
	// for example remoteWrite.tmpDataPath: /tmp
	// it would be converted to flag --remoteWrite.tmpDataPath=/tmp
	// +optional
	extraArgs?: {[string]: string} @go(ExtraArgs,map[string]string)

	// ExtraEnvs that will be added to VMAgent pod
	// +optional
	extraEnvs?: [...v1.#EnvVar] @go(ExtraEnvs,[]v1.EnvVar)

	// ServiceSpec that will be added to vmagent service spec
	// +optional
	serviceSpec?: null | #ServiceSpec @go(ServiceSpec,*ServiceSpec)

	// ShardCount - numbers of shards of VMAgent
	// in this case operator will use 1 deployment/sts per shard with
	// replicas count according to spec.replicas
	// https://victoriametrics.github.io/vmagent.html#scraping-big-number-of-targets
	// +optional
	shardCount?: null | int @go(ShardCount,*int)

	// UpdateStrategy - overrides default update strategy.
	// works only for deployments, statefulset always use OnDelete.
	// +kubebuilder:validation:Enum=Recreate;RollingUpdate
	// +optional
	updateStrategy?: null | appsv1.#DeploymentStrategyType @go(UpdateStrategy,*appsv1.DeploymentStrategyType)

	// RollingUpdate - overrides deployment update params.
	// +optional
	rollingUpdate?: null | appsv1.#RollingUpdateDeployment @go(RollingUpdate,*appsv1.RollingUpdateDeployment)

	// PodDisruptionBudget created by operator
	// +optional
	podDisruptionBudget?: null | #EmbeddedPodDisruptionBudgetSpec @go(PodDisruptionBudget,*EmbeddedPodDisruptionBudgetSpec)

	#EmbeddedProbes
}

// VMAgentRemoteWriteSettings - defines global settings for all remoteWrite urls.
#VMAgentRemoteWriteSettings: {
	// The maximum size in bytes of unpacked request to send to remote storage
	// +optional
	maxBlockSize?: null | int32 @go(MaxBlockSize,*int32)

	// The maximum file-based buffer size in bytes at -remoteWrite.tmpDataPath
	// +optional
	maxDiskUsagePerURL?: null | int32 @go(MaxDiskUsagePerURL,*int32)

	// The number of concurrent queues
	// +optional
	queues?: null | int32 @go(Queues,*int32)

	// Whether to show -remoteWrite.url in the exported metrics. It is hidden by default, since it can contain sensitive auth info
	// +optional
	showURL?: null | bool @go(ShowURL,*bool)

	// Path to directory where temporary data for remote write component is stored (default vmagent-remotewrite-data)
	// +optional
	tmpDataPath?: null | string @go(TmpDataPath,*string)

	// Interval for flushing the data to remote storage. (default 1s)
	// +optional
	// +kubebuilder:validation:Pattern:="[0-9]+(ms|s|m|h)"
	flushInterval?: null | string @go(FlushInterval,*string)
}

// VMAgentRemoteWriteSpec defines the remote storage configuration for VmAgent
// +k8s:openapi-gen=true
#VMAgentRemoteWriteSpec: {
	// URL of the endpoint to send samples to.
	url: string @go(URL)

	// BasicAuth allow an endpoint to authenticate over basic authentication
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// Optional bearer auth token to use for -remoteWrite.url
	// +optional
	bearerTokenSecret?: null | v1.#SecretKeySelector @go(BearerTokenSecret,*v1.SecretKeySelector)

	// Optional labels in the form 'name=value' to add to all the metrics before sending them
	// +optional
	label?: {[string]: string} @go(Labels,map[string]string)

	// ConfigMap with relabeling config which is applied to metrics before sending them to the corresponding -remoteWrite.url
	// +optional
	// +operator-sdk:csv:customresourcedefinitions:type=spec,displayName="Key at Configmap with relabelConfig for remoteWrite",xDescriptors="urn:alm:descriptor:io.kubernetes:ConfigMapKeySelector"
	urlRelabelConfig?: null | v1.#ConfigMapKeySelector @go(UrlRelabelConfig,*v1.ConfigMapKeySelector)

	// InlineUrlRelabelConfig defines relabeling config for remoteWriteURL, it can be defined at crd spec.
	// +optional
	inlineUrlRelabelConfig?: [...#RelabelConfig] @go(InlineUrlRelabelConfig,[]RelabelConfig)

	// TLSConfig describes tls configuration for remote write target
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	// Timeout for sending a single block of data to -remoteWrite.url (default 1m0s)
	// +optional
	// +kubebuilder:validation:Pattern:="[0-9]+(ms|s|m|h)"
	sendTimeout?: null | string @go(SendTimeout,*string)
}

// VmAgentStatus defines the observed state of VmAgent
// +k8s:openapi-gen=true
#VMAgentStatus: {
	// ReplicaCount Total number of non-terminated pods targeted by this VMAlert
	// cluster (their labels match the selector).
	replicas: int32 @go(Replicas)

	// UpdatedReplicas Total number of non-terminated pods targeted by this VMAlert
	// cluster that have the desired version spec.
	updatedReplicas: int32 @go(UpdatedReplicas)

	// AvailableReplicas Total number of available pods (ready for at least minReadySeconds)
	// targeted by this VMAlert cluster.
	availableReplicas: int32 @go(AvailableReplicas)

	// UnavailableReplicas Total number of unavailable pods targeted by this VMAlert cluster.
	unavailableReplicas: int32 @go(UnavailableReplicas)
}

// VMAgent - is a tiny but brave agent, which helps you collect metrics from various sources and stores them in VictoriaMetrics
// or any other Prometheus-compatible storage system that supports the remote_write protocol.
// +operator-sdk:gen-csv:customresourcedefinitions.displayName="VMAgent App"
// +operator-sdk:gen-csv:customresourcedefinitions.resources="Deployment,apps"
// +operator-sdk:gen-csv:customresourcedefinitions.resources="Service,v1"
// +operator-sdk:gen-csv:customresourcedefinitions.resources="Secret,v1"
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +genclient
// +k8s:openapi-gen=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=vmagents,scope=Namespaced
#VMAgent: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec?:     #VMAgentSpec       @go(Spec)
	status?:   #VMAgentStatus     @go(Status)
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// VMAgentList contains a list of VMAgent
#VMAgentList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#VMAgent] @go(Items,[]VMAgent)
}
