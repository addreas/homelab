// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/jetstack/cert-manager/pkg/apis/certmanager/v1

package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
)

// Pending indicates that a CertificateRequest is still in progress.
#CertificateRequestReasonPending: "Pending"

// Failed indicates that a CertificateRequest has failed, either due to
// timing out or some other critical failure.
#CertificateRequestReasonFailed: "Failed"

// Issued indicates that a CertificateRequest has been completed, and that
// the `status.certificate` field is set.
#CertificateRequestReasonIssued: "Issued"

// A CertificateRequest is used to request a signed certificate from one of the
// configured issuers.
//
// All fields within the CertificateRequest's `spec` are immutable after creation.
// A CertificateRequest will either succeed or fail, as denoted by its `status.state`
// field.
//
// A CertificateRequest is a one-shot resource, meaning it represents a single
// point in time request for a certificate and cannot be re-used.
// +k8s:openapi-gen=true
#CertificateRequest: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Desired state of the CertificateRequest resource.
	spec: #CertificateRequestSpec @go(Spec)

	// Status of the CertificateRequest. This is set and managed automatically.
	// +optional
	status: #CertificateRequestStatus @go(Status)
}

// CertificateRequestList is a list of Certificates
#CertificateRequestList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta)
	items: [...#CertificateRequest] @go(Items,[]CertificateRequest)
}

// CertificateRequestSpec defines the desired state of CertificateRequest
#CertificateRequestSpec: {
	// The requested 'duration' (i.e. lifetime) of the Certificate.
	// This option may be ignored/overridden by some issuer types.
	// +optional
	duration?: null | metav1.#Duration @go(Duration,*metav1.Duration)

	// IssuerRef is a reference to the issuer for this CertificateRequest.  If
	// the `kind` field is not set, or set to `Issuer`, an Issuer resource with
	// the given name in the same namespace as the CertificateRequest will be
	// used.  If the `kind` field is set to `ClusterIssuer`, a ClusterIssuer with
	// the provided name will be used. The `name` field in this stanza is
	// required at all times. The group field refers to the API group of the
	// issuer which defaults to `cert-manager.io` if empty.
	issuerRef: cmmeta.#ObjectReference @go(IssuerRef)

	// The PEM-encoded x509 certificate signing request to be submitted to the
	// CA for signing.
	request: bytes @go(Request,[]byte)

	// IsCA will request to mark the certificate as valid for certificate signing
	// when submitting to the issuer.
	// This will automatically add the `cert sign` usage to the list of `usages`.
	// +optional
	isCA?: bool @go(IsCA)

	// Usages is the set of x509 usages that are requested for the certificate.
	// If usages are set they SHOULD be encoded inside the CSR spec
	// Defaults to `digital signature` and `key encipherment` if not specified.
	// +optional
	usages?: [...#KeyUsage] @go(Usages,[]KeyUsage)
}

// CertificateRequestStatus defines the observed state of CertificateRequest and
// resulting signed certificate.
#CertificateRequestStatus: {
	// List of status conditions to indicate the status of a CertificateRequest.
	// Known condition types are `Ready` and `InvalidRequest`.
	// +optional
	conditions?: [...#CertificateRequestCondition] @go(Conditions,[]CertificateRequestCondition)

	// The PEM encoded x509 certificate resulting from the certificate
	// signing request.
	// If not set, the CertificateRequest has either not been completed or has
	// failed. More information on failure can be found by checking the
	// `conditions` field.
	// +optional
	certificate?: bytes @go(Certificate,[]byte)

	// The PEM encoded x509 certificate of the signer, also known as the CA
	// (Certificate Authority).
	// This is set on a best-effort basis by different issuers.
	// If not set, the CA is assumed to be unknown/not available.
	// +optional
	ca?: bytes @go(CA,[]byte)

	// FailureTime stores the time that this CertificateRequest failed. This is
	// used to influence garbage collection and back-off.
	// +optional
	failureTime?: null | metav1.#Time @go(FailureTime,*metav1.Time)
}

// CertificateRequestCondition contains condition information for a CertificateRequest.
#CertificateRequestCondition: {
	// Type of the condition, known values are (`Ready`, `InvalidRequest`).
	type: #CertificateRequestConditionType @go(Type)

	// Status of the condition, one of (`True`, `False`, `Unknown`).
	status: cmmeta.#ConditionStatus @go(Status)

	// LastTransitionTime is the timestamp corresponding to the last status
	// change of this condition.
	// +optional
	lastTransitionTime?: null | metav1.#Time @go(LastTransitionTime,*metav1.Time)

	// Reason is a brief machine readable explanation for the condition's last
	// transition.
	// +optional
	reason?: string @go(Reason)

	// Message is a human readable description of the details of the last
	// transition, complementing reason.
	// +optional
	message?: string @go(Message)
}

// CertificateRequestConditionType represents an Certificate condition value.
#CertificateRequestConditionType: string // #enumCertificateRequestConditionType

#enumCertificateRequestConditionType:
	#CertificateRequestConditionReady |
	#CertificateRequestConditionInvalidRequest

// CertificateRequestConditionReady indicates that a certificate is ready for use.
// This is defined as:
// - The target certificate exists in CertificateRequest.Status
#CertificateRequestConditionReady: #CertificateRequestConditionType & "Ready"

// CertificateRequestConditionInvalidRequest indicates that a certificate
// signer has refused to sign the request due to at least one of the input
// parameters being invalid. Additional information about why the request
// was rejected can be found in the `reason` and `message` fields.
#CertificateRequestConditionInvalidRequest: #CertificateRequestConditionType & "InvalidRequest"
