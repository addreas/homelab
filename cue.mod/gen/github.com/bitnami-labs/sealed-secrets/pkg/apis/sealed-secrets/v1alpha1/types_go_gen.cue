// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/bitnami-labs/sealed-secrets/pkg/apis/sealed-secrets/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	apiv1 "k8s.io/api/core/v1"
)

// SealedSecretName is the name used in SealedSecret CRD
#SealedSecretName: "sealed-secret.bitnami.com"

// SealedSecretPlural is the collection plural used with SealedSecret API
#SealedSecretPlural: "sealedsecrets"

// Annotation namespace prefix
_#annoNs: "sealedsecrets.bitnami.com/"

// SealedSecretClusterWideAnnotation is the name for the annotation for
// setting the secret to be available cluster wide.
#SealedSecretClusterWideAnnotation: "sealedsecrets.bitnami.com/cluster-wide"

// SealedSecretNamespaceWideAnnotation is the name for the annotation for
// setting the secret to be available namespace wide.
#SealedSecretNamespaceWideAnnotation: "sealedsecrets.bitnami.com/namespace-wide"

// SealedSecretManagedAnnotation is the name for the annotation for
// flaging the existing secrets be managed by SealedSecret controller.
#SealedSecretManagedAnnotation: "sealedsecrets.bitnami.com/managed"

// SecretTemplateSpec describes the structure a Secret should have
// when created from a template
#SecretTemplateSpec: {
	// Standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
	// +optional
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)

	// Used to facilitate programmatic handling of secret data.
	// +optional
	type?: apiv1.#SecretType @go(Type) @protobuf(3,bytes,opt,casttype=SecretType)
}

// SealedSecretSpec is the specification of a SealedSecret
#SealedSecretSpec: {
	// Template defines the structure of the Secret that will be
	// created from this sealed secret.
	// +optional
	template?: #SecretTemplateSpec @go(Template)

	// Data is deprecated and will be removed eventually. Use per-value EncryptedData instead.
	data?: bytes @go(Data,[]byte)
	encryptedData: {[string]: string} @go(EncryptedData,map[string]string)
}

// SealedSecretConditionType describes the type of SealedSecret condition
#SealedSecretConditionType: string // #enumSealedSecretConditionType

#enumSealedSecretConditionType:
	#SealedSecretSynced

// SealedSecretSynced means the SealedSecret has been decrypted and the Secret has been updated successfully.
#SealedSecretSynced: #SealedSecretConditionType & "Synced"

// SealedSecretCondition describes the state of a sealed secret at a certain point.
#SealedSecretCondition: {
	// Type of condition for a sealed secret.
	// Valid value: "Synced"
	type: #SealedSecretConditionType @go(Type) @protobuf(1,bytes,opt,casttype=DeploymentConditionType)

	// Status of the condition for a sealed secret.
	// Valid values for "Synced": "True", "False", or "Unknown".
	status: apiv1.#ConditionStatus @go(Status) @protobuf(2,bytes,opt,casttype=k8s.io/api/core/v1.ConditionStatus)

	// The last time this condition was updated.
	lastUpdateTime?: metav1.#Time @go(LastUpdateTime) @protobuf(6,bytes,opt)

	// Last time the condition transitioned from one status to another.
	lastTransitionTime?: metav1.#Time @go(LastTransitionTime) @protobuf(7,bytes,opt)

	// The reason for the condition's last transition.
	reason?: string @go(Reason) @protobuf(4,bytes,opt)

	// A human readable message indicating details about the transition.
	message?: string @go(Message) @protobuf(5,bytes,opt)
}

// SealedSecretStatus is the most recently observed status of the SealedSecret.
#SealedSecretStatus: {
	// ObservedGeneration reflects the generation most recently observed by the sealed-secrets controller.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration) @protobuf(3,varint,opt)

	// Represents the latest available observations of a sealed secret's current state.
	// +optional
	// +patchMergeKey=type
	// +patchStrategy=merge
	conditions?: [...#SealedSecretCondition] @go(Conditions,[]SealedSecretCondition) @protobuf(6,bytes,rep)
}

// SealedSecret is the K8s representation of a "sealed Secret" - a
// regular k8s Secret that has been sealed (encrypted) using the
// controller's key.
#SealedSecret: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec:      #SealedSecretSpec  @go(Spec)

	// +optional
	status?: null | #SealedSecretStatus @go(Status,*SealedSecretStatus)
}

// SealedSecretList represents a list of SealedSecrets
#SealedSecretList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta)
	items: [...#SealedSecret] @go(Items,[]SealedSecret)
}

// ByCreationTimestamp is used to sort a list of secrets
#ByCreationTimestamp: [...apiv1.#Secret]
