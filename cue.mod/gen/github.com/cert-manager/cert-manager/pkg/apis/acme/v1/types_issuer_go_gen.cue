// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/cert-manager/cert-manager/pkg/apis/acme/v1

package v1

import (
	cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
	gwapi "sigs.k8s.io/gateway-api/apis/v1"
	apiextensionsv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
)

// ACMEIssuer contains the specification for an ACME issuer.
// This uses the RFC8555 specification to obtain certificates by completing
// 'challenges' to prove ownership of domain identifiers.
// Earlier draft versions of the ACME specification are not supported.
#ACMEIssuer: {
	// Email is the email address to be associated with the ACME account.
	// This field is optional, but it is strongly recommended to be set.
	// It will be used to contact you in case of issues with your account or
	// certificates, including expiry notification emails.
	// This field may be updated after the account is initially registered.
	// +optional
	email?: string @go(Email)

	// Server is the URL used to access the ACME server's 'directory' endpoint.
	// For example, for Let's Encrypt's staging endpoint, you would use:
	// "https://acme-staging-v02.api.letsencrypt.org/directory".
	// Only ACME v2 endpoints (i.e. RFC 8555) are supported.
	server: string @go(Server)

	// PreferredChain is the chain to use if the ACME server outputs multiple.
	// PreferredChain is no guarantee that this one gets delivered by the ACME
	// endpoint.
	// For example, for Let's Encrypt's DST crosssign you would use:
	// "DST Root CA X3" or "ISRG Root X1" for the newer Let's Encrypt root CA.
	// This value picks the first certificate bundle in the combined set of
	// ACME default and alternative chains that has a root-most certificate with
	// this value as its issuer's commonname.
	// +optional
	// +kubebuilder:validation:MaxLength=64
	preferredChain?: string @go(PreferredChain)

	// Base64-encoded bundle of PEM CAs which can be used to validate the certificate
	// chain presented by the ACME server.
	// Mutually exclusive with SkipTLSVerify; prefer using CABundle to prevent various
	// kinds of security vulnerabilities.
	// If CABundle and SkipTLSVerify are unset, the system certificate bundle inside
	// the container is used to validate the TLS connection.
	// +optional
	caBundle?: bytes @go(CABundle,[]byte)

	// INSECURE: Enables or disables validation of the ACME server TLS certificate.
	// If true, requests to the ACME server will not have the TLS certificate chain
	// validated.
	// Mutually exclusive with CABundle; prefer using CABundle to prevent various
	// kinds of security vulnerabilities.
	// Only enable this option in development environments.
	// If CABundle and SkipTLSVerify are unset, the system certificate bundle inside
	// the container is used to validate the TLS connection.
	// Defaults to false.
	// +optional
	skipTLSVerify?: bool @go(SkipTLSVerify)

	// ExternalAccountBinding is a reference to a CA external account of the ACME
	// server.
	// If set, upon registration cert-manager will attempt to associate the given
	// external account credentials with the registered ACME account.
	// +optional
	externalAccountBinding?: null | #ACMEExternalAccountBinding @go(ExternalAccountBinding,*ACMEExternalAccountBinding)

	// PrivateKey is the name of a Kubernetes Secret resource that will be used to
	// store the automatically generated ACME account private key.
	// Optionally, a `key` may be specified to select a specific entry within
	// the named Secret resource.
	// If `key` is not specified, a default of `tls.key` will be used.
	privateKeySecretRef: cmmeta.#SecretKeySelector @go(PrivateKey)

	// Solvers is a list of challenge solvers that will be used to solve
	// ACME challenges for the matching domains.
	// Solver configurations must be provided in order to obtain certificates
	// from an ACME server.
	// For more information, see: https://cert-manager.io/docs/configuration/acme/
	// +optional
	solvers?: [...#ACMEChallengeSolver] @go(Solvers,[]ACMEChallengeSolver)

	// Enables or disables generating a new ACME account key.
	// If true, the Issuer resource will *not* request a new account but will expect
	// the account key to be supplied via an existing secret.
	// If false, the cert-manager system will generate a new ACME account key
	// for the Issuer.
	// Defaults to false.
	// +optional
	disableAccountKeyGeneration?: bool @go(DisableAccountKeyGeneration)

	// Enables requesting a Not After date on certificates that matches the
	// duration of the certificate. This is not supported by all ACME servers
	// like Let's Encrypt. If set to true when the ACME server does not support
	// it, it will create an error on the Order.
	// Defaults to false.
	// +optional
	enableDurationFeature?: bool @go(EnableDurationFeature)
}

// ACMEExternalAccountBinding is a reference to a CA external account of the ACME
// server.
#ACMEExternalAccountBinding: {
	// keyID is the ID of the CA key that the External Account is bound to.
	keyID: string @go(KeyID)

	// keySecretRef is a Secret Key Selector referencing a data item in a Kubernetes
	// Secret which holds the symmetric MAC key of the External Account Binding.
	// The `key` is the index string that is paired with the key data in the
	// Secret and should not be confused with the key data itself, or indeed with
	// the External Account Binding keyID above.
	// The secret key stored in the Secret **must** be un-padded, base64 URL
	// encoded data.
	keySecretRef: cmmeta.#SecretKeySelector @go(Key)

	// Deprecated: keyAlgorithm field exists for historical compatibility
	// reasons and should not be used. The algorithm is now hardcoded to HS256
	// in golang/x/crypto/acme.
	// +optional
	keyAlgorithm?: #HMACKeyAlgorithm @go(KeyAlgorithm)
}

// HMACKeyAlgorithm is the name of a key algorithm used for HMAC encryption
// +kubebuilder:validation:Enum=HS256;HS384;HS512
#HMACKeyAlgorithm: string // #enumHMACKeyAlgorithm

#enumHMACKeyAlgorithm:
	#HS256 |
	#HS384 |
	#HS512

#HS256: #HMACKeyAlgorithm & "HS256"
#HS384: #HMACKeyAlgorithm & "HS384"
#HS512: #HMACKeyAlgorithm & "HS512"

// An ACMEChallengeSolver describes how to solve ACME challenges for the issuer it is part of.
// A selector may be provided to use different solving strategies for different DNS names.
// Only one of HTTP01 or DNS01 must be provided.
#ACMEChallengeSolver: {
	// Selector selects a set of DNSNames on the Certificate resource that
	// should be solved using this challenge solver.
	// If not specified, the solver will be treated as the 'default' solver
	// with the lowest priority, i.e. if any other solver has a more specific
	// match, it will be used instead.
	// +optional
	selector?: null | #CertificateDNSNameSelector @go(Selector,*CertificateDNSNameSelector)

	// Configures cert-manager to attempt to complete authorizations by
	// performing the HTTP01 challenge flow.
	// It is not possible to obtain certificates for wildcard domain names
	// (e.g. `*.example.com`) using the HTTP01 challenge mechanism.
	// +optional
	http01?: null | #ACMEChallengeSolverHTTP01 @go(HTTP01,*ACMEChallengeSolverHTTP01)

	// Configures cert-manager to attempt to complete authorizations by
	// performing the DNS01 challenge flow.
	// +optional
	dns01?: null | #ACMEChallengeSolverDNS01 @go(DNS01,*ACMEChallengeSolverDNS01)
}

// CertificateDNSNameSelector selects certificates using a label selector, and
// can optionally select individual DNS names within those certificates.
// If both MatchLabels and DNSNames are empty, this selector will match all
// certificates and DNS names within them.
#CertificateDNSNameSelector: {
	// A label selector that is used to refine the set of certificate's that
	// this challenge solver will apply to.
	// +optional
	matchLabels?: {[string]: string} @go(MatchLabels,map[string]string)

	// List of DNSNames that this solver will be used to solve.
	// If specified and a match is found, a dnsNames selector will take
	// precedence over a dnsZones selector.
	// If multiple solvers match with the same dnsNames value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	// +optional
	dnsNames?: [...string] @go(DNSNames,[]string)

	// List of DNSZones that this solver will be used to solve.
	// The most specific DNS zone match specified here will take precedence
	// over other DNS zone matches, so a solver specifying sys.example.com
	// will be selected over one specifying example.com for the domain
	// www.sys.example.com.
	// If multiple solvers match with the same dnsZones value, the solver
	// with the most matching labels in matchLabels will be selected.
	// If neither has more matches, the solver defined earlier in the list
	// will be selected.
	// +optional
	dnsZones?: [...string] @go(DNSZones,[]string)
}

// ACMEChallengeSolverHTTP01 contains configuration detailing how to solve
// HTTP01 challenges within a Kubernetes cluster.
// Typically this is accomplished through creating 'routes' of some description
// that configure ingress controllers to direct traffic to 'solver pods', which
// are responsible for responding to the ACME server's HTTP requests.
// Only one of Ingress / Gateway can be specified.
#ACMEChallengeSolverHTTP01: {
	// The ingress based HTTP01 challenge solver will solve challenges by
	// creating or modifying Ingress resources in order to route requests for
	// '/.well-known/acme-challenge/XYZ' to 'challenge solver' pods that are
	// provisioned by cert-manager for each Challenge to be completed.
	// +optional
	ingress?: null | #ACMEChallengeSolverHTTP01Ingress @go(Ingress,*ACMEChallengeSolverHTTP01Ingress)

	// The Gateway API is a sig-network community API that models service networking
	// in Kubernetes (https://gateway-api.sigs.k8s.io/). The Gateway solver will
	// create HTTPRoutes with the specified labels in the same namespace as the challenge.
	// This solver is experimental, and fields / behaviour may change in the future.
	// +optional
	gatewayHTTPRoute?: null | #ACMEChallengeSolverHTTP01GatewayHTTPRoute @go(GatewayHTTPRoute,*ACMEChallengeSolverHTTP01GatewayHTTPRoute)
}

#ACMEChallengeSolverHTTP01Ingress: {
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	// +optional
	serviceType?: corev1.#ServiceType @go(ServiceType)

	// This field configures the field `ingressClassName` on the created Ingress
	// resources used to solve ACME challenges that use this challenge solver.
	// This is the recommended way of configuring the ingress class. Only one of
	// `class`, `name` or `ingressClassName` may be specified.
	// +optional
	ingressClassName?: null | string @go(IngressClassName,*string)

	// This field configures the annotation `kubernetes.io/ingress.class` when
	// creating Ingress resources to solve ACME challenges that use this
	// challenge solver. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	// +optional
	class?: null | string @go(Class,*string)

	// The name of the ingress resource that should have ACME challenge solving
	// routes inserted into it in order to solve HTTP01 challenges.
	// This is typically used in conjunction with ingress controllers like
	// ingress-gce, which maintains a 1:1 mapping between external IPs and
	// ingress resources. Only one of `class`, `name` or `ingressClassName` may
	// be specified.
	// +optional
	name?: string @go(Name)

	// Optional pod template used to configure the ACME challenge solver pods
	// used for HTTP01 challenges.
	// +optional
	podTemplate?: null | #ACMEChallengeSolverHTTP01IngressPodTemplate @go(PodTemplate,*ACMEChallengeSolverHTTP01IngressPodTemplate)

	// Optional ingress template used to configure the ACME challenge solver
	// ingress used for HTTP01 challenges.
	// +optional
	ingressTemplate?: null | #ACMEChallengeSolverHTTP01IngressTemplate @go(IngressTemplate,*ACMEChallengeSolverHTTP01IngressTemplate)
}

// The ACMEChallengeSolverHTTP01GatewayHTTPRoute solver will create HTTPRoute objects for a Gateway class
// routing to an ACME challenge solver pod.
#ACMEChallengeSolverHTTP01GatewayHTTPRoute: {
	// Optional service type for Kubernetes solver service. Supported values
	// are NodePort or ClusterIP. If unset, defaults to NodePort.
	// +optional
	serviceType?: corev1.#ServiceType @go(ServiceType)

	// Custom labels that will be applied to HTTPRoutes created by cert-manager
	// while solving HTTP-01 challenges.
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)

	// When solving an HTTP-01 challenge, cert-manager creates an HTTPRoute.
	// cert-manager needs to know which parentRefs should be used when creating
	// the HTTPRoute. Usually, the parentRef references a Gateway. See:
	// https://gateway-api.sigs.k8s.io/api-types/httproute/#attaching-to-gateways
	parentRefs?: [...gwapi.#ParentReference] @go(ParentRefs,[]gwapi.ParentReference)

	// Optional pod template used to configure the ACME challenge solver pods
	// used for HTTP01 challenges.
	// +optional
	podTemplate?: null | #ACMEChallengeSolverHTTP01IngressPodTemplate @go(PodTemplate,*ACMEChallengeSolverHTTP01IngressPodTemplate)
}

#ACMEChallengeSolverHTTP01IngressPodTemplate: {
	// ObjectMeta overrides for the pod used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	// +optional
	metadata?: #ACMEChallengeSolverHTTP01IngressPodObjectMeta @go(ACMEChallengeSolverHTTP01IngressPodObjectMeta)

	// PodSpec defines overrides for the HTTP01 challenge solver pod.
	// Check ACMEChallengeSolverHTTP01IngressPodSpec to find out currently supported fields.
	// All other fields will be ignored.
	// +optional
	spec?: #ACMEChallengeSolverHTTP01IngressPodSpec @go(Spec)
}

#ACMEChallengeSolverHTTP01IngressPodObjectMeta: {
	// Annotations that should be added to the created ACME HTTP01 solver pods.
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)

	// Labels that should be added to the created ACME HTTP01 solver pods.
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)
}

#ACMEChallengeSolverHTTP01IngressPodSpec: {
	// NodeSelector is a selector which must be true for the pod to fit on a node.
	// Selector which must match a node's labels for the pod to be scheduled on that node.
	// More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
	// +optional
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)

	// If specified, the pod's scheduling constraints
	// +optional
	affinity?: null | corev1.#Affinity @go(Affinity,*corev1.Affinity)

	// If specified, the pod's tolerations.
	// +optional
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)

	// If specified, the pod's priorityClassName.
	// +optional
	priorityClassName?: string @go(PriorityClassName)

	// If specified, the pod's service account
	// +optional
	serviceAccountName?: string @go(ServiceAccountName)

	// If specified, the pod's imagePullSecrets
	// +optional
	imagePullSecrets?: [...corev1.#LocalObjectReference] @go(ImagePullSecrets,[]corev1.LocalObjectReference)

	// If specified, the pod's security context
	// +optional
	securityContext?: null | #ACMEChallengeSolverHTTP01IngressPodSecurityContext @go(SecurityContext,*ACMEChallengeSolverHTTP01IngressPodSecurityContext)
}

#ACMEChallengeSolverHTTP01IngressTemplate: {
	// ObjectMeta overrides for the ingress used to solve HTTP01 challenges.
	// Only the 'labels' and 'annotations' fields may be set.
	// If labels or annotations overlap with in-built values, the values here
	// will override the in-built values.
	// +optional
	metadata?: #ACMEChallengeSolverHTTP01IngressObjectMeta @go(ACMEChallengeSolverHTTP01IngressObjectMeta)
}

#ACMEChallengeSolverHTTP01IngressObjectMeta: {
	// Annotations that should be added to the created ACME HTTP01 solver ingress.
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)

	// Labels that should be added to the created ACME HTTP01 solver ingress.
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string)
}

// Used to configure a DNS01 challenge provider to be used when solving DNS01
// challenges.
// Only one DNS provider may be configured per solver.
#ACMEChallengeSolverDNS01: {
	// CNAMEStrategy configures how the DNS01 provider should handle CNAME
	// records when found in DNS zones.
	// +optional
	cnameStrategy?: #CNAMEStrategy @go(CNAMEStrategy)

	// Use the Akamai DNS zone management API to manage DNS01 challenge records.
	// +optional
	akamai?: null | #ACMEIssuerDNS01ProviderAkamai @go(Akamai,*ACMEIssuerDNS01ProviderAkamai)

	// Use the Google Cloud DNS API to manage DNS01 challenge records.
	// +optional
	cloudDNS?: null | #ACMEIssuerDNS01ProviderCloudDNS @go(CloudDNS,*ACMEIssuerDNS01ProviderCloudDNS)

	// Use the Cloudflare API to manage DNS01 challenge records.
	// +optional
	cloudflare?: null | #ACMEIssuerDNS01ProviderCloudflare @go(Cloudflare,*ACMEIssuerDNS01ProviderCloudflare)

	// Use the AWS Route53 API to manage DNS01 challenge records.
	// +optional
	route53?: null | #ACMEIssuerDNS01ProviderRoute53 @go(Route53,*ACMEIssuerDNS01ProviderRoute53)

	// Use the Microsoft Azure DNS API to manage DNS01 challenge records.
	// +optional
	azureDNS?: null | #ACMEIssuerDNS01ProviderAzureDNS @go(AzureDNS,*ACMEIssuerDNS01ProviderAzureDNS)

	// Use the DigitalOcean DNS API to manage DNS01 challenge records.
	// +optional
	digitalocean?: null | #ACMEIssuerDNS01ProviderDigitalOcean @go(DigitalOcean,*ACMEIssuerDNS01ProviderDigitalOcean)

	// Use the 'ACME DNS' (https://github.com/joohoi/acme-dns) API to manage
	// DNS01 challenge records.
	// +optional
	acmeDNS?: null | #ACMEIssuerDNS01ProviderAcmeDNS @go(AcmeDNS,*ACMEIssuerDNS01ProviderAcmeDNS)

	// Use RFC2136 ("Dynamic Updates in the Domain Name System") (https://datatracker.ietf.org/doc/rfc2136/)
	// to manage DNS01 challenge records.
	// +optional
	rfc2136?: null | #ACMEIssuerDNS01ProviderRFC2136 @go(RFC2136,*ACMEIssuerDNS01ProviderRFC2136)

	// Configure an external webhook based DNS01 challenge solver to manage
	// DNS01 challenge records.
	// +optional
	webhook?: null | #ACMEIssuerDNS01ProviderWebhook @go(Webhook,*ACMEIssuerDNS01ProviderWebhook)
}

#ACMEChallengeSolverHTTP01IngressPodSecurityContext: {
	// The SELinux context to be applied to all containers.
	// If unspecified, the container runtime will allocate a random SELinux context for each
	// container.  May also be set in SecurityContext.  If set in
	// both SecurityContext and PodSecurityContext, the value specified in SecurityContext
	// takes precedence for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	seLinuxOptions?: null | corev1.#SELinuxOptions @go(SELinuxOptions,*corev1.SELinuxOptions)

	// The UID to run the entrypoint of the container process.
	// Defaults to user specified in image metadata if unspecified.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	runAsUser?: null | int64 @go(RunAsUser,*int64)

	// The GID to run the entrypoint of the container process.
	// Uses runtime default if unset.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence
	// for that container.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	runAsGroup?: null | int64 @go(RunAsGroup,*int64)

	// Indicates that the container must run as a non-root user.
	// If true, the Kubelet will validate the image at runtime to ensure that it
	// does not run as UID 0 (root) and fail to start the container if it does.
	// If unset or false, no such validation will be performed.
	// May also be set in SecurityContext.  If set in both SecurityContext and
	// PodSecurityContext, the value specified in SecurityContext takes precedence.
	// +optional
	runAsNonRoot?: null | bool @go(RunAsNonRoot,*bool)

	// A list of groups applied to the first process run in each container, in addition
	// to the container's primary GID, the fsGroup (if specified), and group memberships
	// defined in the container image for the uid of the container process. If unspecified,
	// no additional groups are added to any container. Note that group memberships
	// defined in the container image for the uid of the container process are still effective,
	// even if they are not included in this list.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	supplementalGroups?: [...int64] @go(SupplementalGroups,[]int64)

	// A special supplemental group that applies to all containers in a pod.
	// Some volume types allow the Kubelet to change the ownership of that volume
	// to be owned by the pod:
	//
	// 1. The owning GID will be the FSGroup
	// 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
	// 3. The permission bits are OR'd with rw-rw----
	//
	// If unset, the Kubelet will not modify the ownership and permissions of any volume.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	fsGroup?: null | int64 @go(FSGroup,*int64)

	// Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
	// sysctls (by the container runtime) might fail to launch.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	sysctls?: [...corev1.#Sysctl] @go(Sysctls,[]corev1.Sysctl)

	// fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
	// before being exposed inside Pod. This field will only apply to
	// volume types which support fsGroup based ownership(and permissions).
	// It will have no effect on ephemeral volume types such as: secret, configmaps
	// and emptydir.
	// Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	fsGroupChangePolicy?: null | corev1.#PodFSGroupChangePolicy @go(FSGroupChangePolicy,*corev1.PodFSGroupChangePolicy)

	// The seccomp options to use by the containers in this pod.
	// Note that this field cannot be set when spec.os.name is windows.
	// +optional
	seccompProfile?: null | corev1.#SeccompProfile @go(SeccompProfile,*corev1.SeccompProfile)
}

// CNAMEStrategy configures how the DNS01 provider should handle CNAME records
// when found in DNS zones.
// By default, the None strategy will be applied (i.e. do not follow CNAMEs).
// +kubebuilder:validation:Enum=None;Follow
#CNAMEStrategy: string

// NoneStrategy indicates that no CNAME resolution strategy should be used
// when determining which DNS zone to update during DNS01 challenges.
#NoneStrategy: "None"

// FollowStrategy will cause cert-manager to recurse through CNAMEs in
// order to determine which DNS zone to update during DNS01 challenges.
// This is useful if you do not want to grant cert-manager access to your
// root DNS zone, and instead delegate the _acme-challenge.example.com
// subdomain to some other, less privileged domain.
#FollowStrategy: "Follow"

// ACMEIssuerDNS01ProviderAkamai is a structure containing the DNS
// configuration for Akamai DNS—Zone Record Management API
#ACMEIssuerDNS01ProviderAkamai: {
	serviceConsumerDomain: string                    @go(ServiceConsumerDomain)
	clientTokenSecretRef:  cmmeta.#SecretKeySelector @go(ClientToken)
	clientSecretSecretRef: cmmeta.#SecretKeySelector @go(ClientSecret)
	accessTokenSecretRef:  cmmeta.#SecretKeySelector @go(AccessToken)
}

// ACMEIssuerDNS01ProviderCloudDNS is a structure containing the DNS
// configuration for Google Cloud DNS
#ACMEIssuerDNS01ProviderCloudDNS: {
	// +optional
	serviceAccountSecretRef?: null | cmmeta.#SecretKeySelector @go(ServiceAccount,*cmmeta.SecretKeySelector)
	project:                  string                           @go(Project)

	// HostedZoneName is an optional field that tells cert-manager in which
	// Cloud DNS zone the challenge record has to be created.
	// If left empty cert-manager will automatically choose a zone.
	// +optional
	hostedZoneName?: string @go(HostedZoneName)
}

// ACMEIssuerDNS01ProviderCloudflare is a structure containing the DNS
// configuration for Cloudflare.
// One of `apiKeySecretRef` or `apiTokenSecretRef` must be provided.
#ACMEIssuerDNS01ProviderCloudflare: {
	// Email of the account, only required when using API key based authentication.
	// +optional
	email?: string @go(Email)

	// API key to use to authenticate with Cloudflare.
	// Note: using an API token to authenticate is now the recommended method
	// as it allows greater control of permissions.
	// +optional
	apiKeySecretRef?: null | cmmeta.#SecretKeySelector @go(APIKey,*cmmeta.SecretKeySelector)

	// API token used to authenticate with Cloudflare.
	// +optional
	apiTokenSecretRef?: null | cmmeta.#SecretKeySelector @go(APIToken,*cmmeta.SecretKeySelector)
}

// ACMEIssuerDNS01ProviderDigitalOcean is a structure containing the DNS
// configuration for DigitalOcean Domains
#ACMEIssuerDNS01ProviderDigitalOcean: {
	tokenSecretRef: cmmeta.#SecretKeySelector @go(Token)
}

// ACMEIssuerDNS01ProviderRoute53 is a structure containing the Route 53
// configuration for AWS
#ACMEIssuerDNS01ProviderRoute53: {
	// Auth configures how cert-manager authenticates.
	// +optional
	auth?: null | #Route53Auth @go(Auth,*Route53Auth)

	// The AccessKeyID is used for authentication.
	// Cannot be set when SecretAccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	// +optional
	accessKeyID?: string @go(AccessKeyID)

	// The SecretAccessKey is used for authentication. If set, pull the AWS
	// access key ID from a key within a Kubernetes Secret.
	// Cannot be set when AccessKeyID is set.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	// +optional
	accessKeyIDSecretRef?: null | cmmeta.#SecretKeySelector @go(SecretAccessKeyID,*cmmeta.SecretKeySelector)

	// The SecretAccessKey is used for authentication.
	// If neither the Access Key nor Key ID are set, we fall-back to using env
	// vars, shared credentials file or AWS Instance metadata,
	// see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
	// +optional
	secretAccessKeySecretRef?: cmmeta.#SecretKeySelector @go(SecretAccessKey)

	// Role is a Role ARN which the Route53 provider will assume using either the explicit credentials AccessKeyID/SecretAccessKey
	// or the inferred credentials from environment variables, shared credentials file or AWS Instance metadata
	// +optional
	role?: string @go(Role)

	// If set, the provider will manage only this zone in Route53 and will not do a lookup using the route53:ListHostedZonesByName api call.
	// +optional
	hostedZoneID?: string @go(HostedZoneID)

	// Override the AWS region.
	//
	// Route53 is a global service and does not have regional endpoints but the
	// region specified here (or via environment variables) is used as a hint to
	// help compute the correct AWS credential scope and partition when it
	// connects to Route53. See:
	// - [Amazon Route 53 endpoints and quotas](https://docs.aws.amazon.com/general/latest/gr/r53.html)
	// - [Global services](https://docs.aws.amazon.com/whitepapers/latest/aws-fault-isolation-boundaries/global-services.html)
	//
	// If you omit this region field, cert-manager will use the region from
	// AWS_REGION and AWS_DEFAULT_REGION environment variables, if they are set
	// in the cert-manager controller Pod.
	//
	// The `region` field is not needed if you use [IAM Roles for Service Accounts (IRSA)](https://docs.aws.amazon.com/eks/latest/userguide/iam-roles-for-service-accounts.html).
	// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
	// [Amazon EKS Pod Identity Webhook](https://github.com/aws/amazon-eks-pod-identity-webhook).
	// In this case this `region` field value is ignored.
	//
	// The `region` field is not needed if you use [EKS Pod Identities](https://docs.aws.amazon.com/eks/latest/userguide/pod-identities.html).
	// Instead an AWS_REGION environment variable is added to the cert-manager controller Pod by:
	// [Amazon EKS Pod Identity Agent](https://github.com/aws/eks-pod-identity-agent),
	// In this case this `region` field value is ignored.
	//
	// +optional
	region?: string @go(Region)
}

// Route53Auth is configuration used to authenticate with a Route53.
#Route53Auth: {
	// Kubernetes authenticates with Route53 using AssumeRoleWithWebIdentity
	// by passing a bound ServiceAccount token.
	kubernetes?: null | #Route53KubernetesAuth @go(Kubernetes,*Route53KubernetesAuth)
}

// Route53KubernetesAuth is a configuration to authenticate against Route53
// using a bound Kubernetes ServiceAccount token.
#Route53KubernetesAuth: {
	// A reference to a service account that will be used to request a bound
	// token (also known as "projected token"). To use this field, you must
	// configure an RBAC rule to let cert-manager request a token.
	serviceAccountRef?: null | #ServiceAccountRef @go(ServiceAccountRef,*ServiceAccountRef)
}

// ServiceAccountRef is a service account used by cert-manager to request a
// token. The expiration of the token is also set by cert-manager to 10 minutes.
#ServiceAccountRef: {
	// Name of the ServiceAccount used to request a token.
	name: string @go(Name)

	// TokenAudiences is an optional list of audiences to include in the
	// token passed to AWS. The default token consisting of the issuer's namespace
	// and name is always included.
	// If unset the audience defaults to `sts.amazonaws.com`.
	// +optional
	audiences?: [...string] @go(TokenAudiences,[]string)
}

// ACMEIssuerDNS01ProviderAzureDNS is a structure containing the
// configuration for Azure DNS
#ACMEIssuerDNS01ProviderAzureDNS: {
	// Auth: Azure Service Principal:
	// The ClientID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientSecret and TenantID must also be set.
	// +optional
	clientID?: string @go(ClientID)

	// Auth: Azure Service Principal:
	// A reference to a Secret containing the password associated with the Service Principal.
	// If set, ClientID and TenantID must also be set.
	// +optional
	clientSecretSecretRef?: null | cmmeta.#SecretKeySelector @go(ClientSecret,*cmmeta.SecretKeySelector)

	// ID of the Azure subscription
	subscriptionID: string @go(SubscriptionID)

	// Auth: Azure Service Principal:
	// The TenantID of the Azure Service Principal used to authenticate with Azure DNS.
	// If set, ClientID and ClientSecret must also be set.
	// +optional
	tenantID?: string @go(TenantID)

	// resource group the DNS zone is located in
	resourceGroupName: string @go(ResourceGroupName)

	// name of the DNS zone that should be used
	// +optional
	hostedZoneName?: string @go(HostedZoneName)

	// name of the Azure environment (default AzurePublicCloud)
	// +optional
	environment?: #AzureDNSEnvironment @go(Environment)

	// Auth: Azure Workload Identity or Azure Managed Service Identity:
	// Settings to enable Azure Workload Identity or Azure Managed Service Identity
	// If set, ClientID, ClientSecret and TenantID must not be set.
	// +optional
	managedIdentity?: null | #AzureManagedIdentity @go(ManagedIdentity,*AzureManagedIdentity)
}

// AzureManagedIdentity contains the configuration for Azure Workload Identity or Azure Managed Service Identity
// If the AZURE_FEDERATED_TOKEN_FILE environment variable is set, the Azure Workload Identity will be used.
// Otherwise, we fall-back to using Azure Managed Service Identity.
#AzureManagedIdentity: {
	// client ID of the managed identity, can not be used at the same time as resourceID
	// +optional
	clientID?: string @go(ClientID)

	// resource ID of the managed identity, can not be used at the same time as clientID
	// Cannot be used for Azure Managed Service Identity
	// +optional
	resourceID?: string @go(ResourceID)
}

// +kubebuilder:validation:Enum=AzurePublicCloud;AzureChinaCloud;AzureGermanCloud;AzureUSGovernmentCloud
#AzureDNSEnvironment: string // #enumAzureDNSEnvironment

#enumAzureDNSEnvironment:
	#AzurePublicCloud |
	#AzureChinaCloud |
	#AzureGermanCloud |
	#AzureUSGovernmentCloud

#AzurePublicCloud:       #AzureDNSEnvironment & "AzurePublicCloud"
#AzureChinaCloud:        #AzureDNSEnvironment & "AzureChinaCloud"
#AzureGermanCloud:       #AzureDNSEnvironment & "AzureGermanCloud"
#AzureUSGovernmentCloud: #AzureDNSEnvironment & "AzureUSGovernmentCloud"

// ACMEIssuerDNS01ProviderAcmeDNS is a structure containing the
// configuration for ACME-DNS servers
#ACMEIssuerDNS01ProviderAcmeDNS: {
	host:             string                    @go(Host)
	accountSecretRef: cmmeta.#SecretKeySelector @go(AccountSecret)
}

// ACMEIssuerDNS01ProviderRFC2136 is a structure containing the
// configuration for RFC2136 DNS
#ACMEIssuerDNS01ProviderRFC2136: {
	// The IP address or hostname of an authoritative DNS server supporting
	// RFC2136 in the form host:port. If the host is an IPv6 address it must be
	// enclosed in square brackets (e.g [2001:db8::1]) ; port is optional.
	// This field is required.
	nameserver: string @go(Nameserver)

	// The name of the secret containing the TSIG value.
	// If ``tsigKeyName`` is defined, this field is required.
	// +optional
	tsigSecretSecretRef?: cmmeta.#SecretKeySelector @go(TSIGSecret)

	// The TSIG Key name configured in the DNS.
	// If ``tsigSecretSecretRef`` is defined, this field is required.
	// +optional
	tsigKeyName?: string @go(TSIGKeyName)

	// The TSIG Algorithm configured in the DNS supporting RFC2136. Used only
	// when ``tsigSecretSecretRef`` and ``tsigKeyName`` are defined.
	// Supported values are (case-insensitive): ``HMACMD5`` (default),
	// ``HMACSHA1``, ``HMACSHA256`` or ``HMACSHA512``.
	// +optional
	tsigAlgorithm?: string @go(TSIGAlgorithm)
}

// ACMEIssuerDNS01ProviderWebhook specifies configuration for a webhook DNS01
// provider, including where to POST ChallengePayload resources.
#ACMEIssuerDNS01ProviderWebhook: {
	// The API group name that should be used when POSTing ChallengePayload
	// resources to the webhook apiserver.
	// This should be the same as the GroupName specified in the webhook
	// provider implementation.
	groupName: string @go(GroupName)

	// The name of the solver to use, as defined in the webhook provider
	// implementation.
	// This will typically be the name of the provider, e.g. 'cloudflare'.
	solverName: string @go(SolverName)

	// Additional configuration that should be passed to the webhook apiserver
	// when challenges are processed.
	// This can contain arbitrary JSON data.
	// Secret values should not be specified in this stanza.
	// If secret values are needed (e.g. credentials for a DNS service), you
	// should use a SecretKeySelector to reference a Secret resource.
	// For details on the schema of this field, consult the webhook provider
	// implementation's documentation.
	// +optional
	config?: null | apiextensionsv1.#JSON @go(Config,*apiextensionsv1.JSON)
}

#ACMEIssuerStatus: {
	// URI is the unique account identifier, which can also be used to retrieve
	// account details from the CA
	// +optional
	uri?: string @go(URI)

	// LastRegisteredEmail is the email associated with the latest registered
	// ACME account, in order to track changes made to registered account
	// associated with the  Issuer
	// +optional
	lastRegisteredEmail?: string @go(LastRegisteredEmail)

	// LastPrivateKeyHash is a hash of the private key associated with the latest
	// registered ACME account, in order to track changes made to registered account
	// associated with the Issuer
	// +optional
	lastPrivateKeyHash?: string @go(LastPrivateKeyHash)
}
