// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/pivotal/kpack/pkg/apis/build/v1alpha2

package v1alpha2

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
	corev1alpha1 "github.com/pivotal/kpack/pkg/apis/core/v1alpha1"
	"k8s.io/apimachinery/pkg/api/resource"
)

#ImageKind:   "Image"
#ImageCRName: "images.kpack.io"

// +k8s:openapi-gen=true
#Image: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec:      #ImageSpec         @go(Spec)
	status?:   #ImageStatus       @go(Status)
}

// +k8s:openapi-gen=true
#ImageSpec: {
	tag:                       string                             @go(Tag)
	builder?:                  corev1.#ObjectReference            @go(Builder)
	serviceAccountName?:       string                             @go(ServiceAccountName)
	source:                    corev1alpha1.#SourceConfig         @go(Source)
	cache?:                    null | #ImageCacheConfig           @go(Cache,*ImageCacheConfig)
	failedBuildHistoryLimit?:  null | int64                       @go(FailedBuildHistoryLimit,*int64)
	successBuildHistoryLimit?: null | int64                       @go(SuccessBuildHistoryLimit,*int64)
	imageTaggingStrategy?:     corev1alpha1.#ImageTaggingStrategy @go(ImageTaggingStrategy)
	projectDescriptorPath?:    string                             @go(ProjectDescriptorPath)
	build?:                    null | #ImageBuild                 @go(Build,*ImageBuild)
	notary?:                   null | corev1alpha1.#NotaryConfig  @go(Notary,*corev1alpha1.NotaryConfig)
	cosign?:                   null | #CosignConfig               @go(Cosign,*CosignConfig)
	defaultProcess?:           string                             @go(DefaultProcess)

	// +listType
	additionalTags?: [...string] @go(AdditionalTags,[]string)
}

// +k8s:openapi-gen=true
#ImageBuild: {
	// +listType
	services?: #Services @go(Services)

	// +listType
	cnbBindings?: corev1alpha1.#CNBBindings @go(CNBBindings)

	// +listType
	env?: [...corev1.#EnvVar] @go(Env,[]corev1.EnvVar)
	resources?: corev1.#ResourceRequirements @go(Resources)

	// +listType
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)
	affinity?:         null | corev1.#Affinity @go(Affinity,*corev1.Affinity)
	runtimeClassName?: null | string           @go(RuntimeClassName,*string)
	schedulerName?:    string                  @go(SchedulerName)
	buildTimeout?:     null | int64            @go(BuildTimeout,*int64)
	creationTime?:     string                  @go(CreationTime)
}

// +k8s:openapi-gen=true
#ImageCacheConfig: {
	volume?:   null | #ImagePersistentVolumeCache @go(Volume,*ImagePersistentVolumeCache)
	registry?: null | #RegistryCache              @go(Registry,*RegistryCache)
}

// +k8s:openapi-gen=true
#ImagePersistentVolumeCache: {
	size?:             null | resource.#Quantity @go(Size,*resource.Quantity)
	storageClassName?: string                    @go(StorageClassName)
}

// +k8s:openapi-gen=true
#RegistryCache: {
	tag: string @go(Tag)
}

// +k8s:openapi-gen=true
#ImageBuilder: {
	metav1.#TypeMeta
	name: string @go(Name)
}

// +k8s:openapi-gen=true
#ImageStatus: {
	corev1alpha1.#Status
	latestBuildRef?:             string @go(LatestBuildRef)
	latestBuildImageGeneration?: int64  @go(LatestBuildImageGeneration)
	latestImage?:                string @go(LatestImage)
	latestStack?:                string @go(LatestStack)
	buildCounter?:               int64  @go(BuildCounter)
	buildCacheName?:             string @go(BuildCacheName)
	latestBuildReason?:          string @go(LatestBuildReason)
}

// +k8s:openapi-gen=true
#ImageList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta)

	// +k8s:listType=atomic
	items: [...#Image] @go(Items,[]Image)
}

#ConditionBuilderReady: corev1alpha1.#ConditionType & "BuilderReady"
