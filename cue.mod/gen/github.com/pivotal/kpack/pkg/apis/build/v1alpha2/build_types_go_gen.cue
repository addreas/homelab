// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/pivotal/kpack/pkg/apis/build/v1alpha2

package v1alpha2

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1alpha1 "github.com/pivotal/kpack/pkg/apis/core/v1alpha1"
	corev1 "k8s.io/api/core/v1"
)

#BuildKind:   "Build"
#BuildCRName: "builds.kpack.io"

// +k8s:openapi-gen=true
#Build: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)
	spec:      #BuildSpec         @go(Spec)
	status?:   #BuildStatus       @go(Status)
}

// +k8s:openapi-gen=true
#BuildSpec: {
	// +listType
	tags?: [...string] @go(Tags,[]string)
	builder?:            corev1alpha1.#BuildBuilderSpec @go(Builder)
	serviceAccountName?: string                         @go(ServiceAccountName)
	source:              corev1alpha1.#SourceConfig     @go(Source)
	cache?:              null | #BuildCacheConfig       @go(Cache,*BuildCacheConfig)

	// +listType
	services?: #Services @go(Services)

	// +listType
	cnbBindings?: corev1alpha1.#CNBBindings @go(CNBBindings)

	// +listType
	env?: [...corev1.#EnvVar] @go(Env,[]corev1.EnvVar)
	projectDescriptorPath?: string                            @go(ProjectDescriptorPath)
	resources?:             corev1.#ResourceRequirements      @go(Resources)
	lastBuild?:             null | #LastBuild                 @go(LastBuild,*LastBuild)
	notary?:                null | corev1alpha1.#NotaryConfig @go(Notary,*corev1alpha1.NotaryConfig)
	cosign?:                null | #CosignConfig              @go(Cosign,*CosignConfig)
	defaultProcess?:        string                            @go(DefaultProcess)

	// +listType
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)
	affinity?:          null | corev1.#Affinity @go(Affinity,*corev1.Affinity)
	runtimeClassName?:  null | string           @go(RuntimeClassName,*string)
	schedulerName?:     string                  @go(SchedulerName)
	priorityClassName?: string                  @go(PriorityClassName)
}

// +k8s:openapi-gen=true
#BuildCacheConfig: {
	volume?:   null | #BuildPersistentVolumeCache @go(Volume,*BuildPersistentVolumeCache)
	registry?: null | #RegistryCache              @go(Registry,*RegistryCache)
}

// +k8s:openapi-gen=true
#BuildPersistentVolumeCache: {
	persistentVolumeClaimName?: string @go(ClaimName)
}

// +k8s:openapi-gen=true
#Services: [...corev1.#ObjectReference]

// +k8s:openapi-gen=true
#LastBuild: {
	image?:   string      @go(Image)
	cache?:   #BuildCache @go(Cache)
	stackId?: string      @go(StackId)
}

// +k8s:openapi-gen=true
#BuildCache: {
	image?: string @go(Image)
}

// +k8s:openapi-gen=true
#BuildStack: {
	runImage?: string @go(RunImage)
	id?:       string @go(ID)
}

// +k8s:openapi-gen=true
#BuildStatus: {
	corev1alpha1.#Status
	buildMetadata?:    corev1alpha1.#BuildpackMetadataList @go(BuildMetadata)
	stack?:            corev1alpha1.#BuildStack            @go(Stack)
	latestImage?:      string                              @go(LatestImage)
	latestCacheImage?: string                              @go(LatestCacheImage)
	podName?:          string                              @go(PodName)

	// +listType
	stepStates?: [...corev1.#ContainerState] @go(StepStates,[]corev1.ContainerState)

	// +listType
	stepsCompleted?: [...string] @go(StepsCompleted,[]string)
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
#BuildList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta)

	// +k8s:listType=atomic
	items: [...#Build] @go(Items,[]Build)
}
