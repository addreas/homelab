// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/grafana/agent/pkg/operator/apis/monitoring/v1alpha1

package v1alpha1

import (
	prom_v1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/api/core/v1"
)

// MetricsSubsystemSpec defines global settings to apply across the
// Metrics subsystem.
#MetricsSubsystemSpec: {
	// RemoteWrite controls default remote_write settings for all instances. If
	// an instance does not provide its own RemoteWrite settings, these will be
	// used instead.
	remoteWrite?: [...#RemoteWriteSpec] @go(RemoteWrite,[]RemoteWriteSpec)

	// Replicas of each shard to deploy for metrics pods. Number of replicas
	// multiplied by the number of shards is the total number of pods created.
	replicas?: null | int32 @go(Replicas,*int32)

	// Shards to distribute targets onto. Number of replicas multiplied by the
	// number of shards is the total number of pods created. Note that scaling
	// down shards does not reshard data onto remaining instances; it must be
	// manually moved. Increasing shards does not reshard data either, but it will
	// continue to be available from the same instances. Sharding is performed on
	// the content of the __address__ target meta-label.
	shards?: null | int32 @go(Shards,*int32)

	// ReplicaExternalLabelName is the name of the metrics external label used
	// to denote the replica name. Defaults to __replica__. The external label is _not_
	// added when the value is set to the empty string.
	replicaExternalLabelName?: null | string @go(ReplicaExternalLabelName,*string)

	// MetricsExternalLabelName is the name of the external label used to
	// denote Grafana Agent cluster. Defaults to "cluster." The external label is
	// _not_ added when the value is set to the empty string.
	metricsExternalLabelName?: null | string @go(MetricsExternalLabelName,*string)

	// ScrapeInterval is the time between consecutive scrapes.
	scrapeInterval?: string @go(ScrapeInterval)

	// ScrapeTimeout is the time to wait for a target to respond before marking a
	// scrape as failed.
	scrapeTimeout?: string @go(ScrapeTimeout)

	// ExternalLabels are labels to add to any time series when sending data over
	// remote_write.
	externalLabels?: {[string]: string} @go(ExternalLabels,map[string]string)

	// ArbitraryFSAccessThroughSMs configures whether configuration based on a
	// ServiceMonitor can access arbitrary files on the file system of the
	// Grafana Agent container, e.g., bearer token files.
	arbitraryFSAccessThroughSMs?: prom_v1.#ArbitraryFSAccessThroughSMsConfig @go(ArbitraryFSAccessThroughSMs)

	// OverrideHonorLabels, if true, overrides all configured honor_labels read
	// from ServiceMonitor or PodMonitor and sets them to false.
	overrideHonorLabels?: bool @go(OverrideHonorLabels)

	// OverrideHonorTimestamps allows global enforcement for honoring timestamps in all scrape configs.
	overrideHonorTimestamps?: bool @go(OverrideHonorTimestamps)

	// IgnoreNamespaceSelectors, if true, ignores NamespaceSelector settings
	// from the PodMonitor and ServiceMonitor configs, so that they only
	// discover endpoints within their current namespace.
	ignoreNamespaceSelectors?: bool @go(IgnoreNamespaceSelectors)

	// EnforcedNamespaceLabel enforces adding a namespace label of origin for
	// each metric that is user-created. The label value is always the
	// namespace of the object that is being created.
	enforcedNamespaceLabel?: string @go(EnforcedNamespaceLabel)

	// EnforcedSampleLimit defines a global limit on the number of scraped samples
	// that are accepted. This overrides any SampleLimit set per
	// ServiceMonitor and/or PodMonitor. It is meant to be used by admins to
	// enforce the SampleLimit to keep the overall number of samples and series
	// under the desired limit. Note that if a SampleLimit from a ServiceMonitor
	// or PodMonitor is lower, that value is used instead.
	enforcedSampleLimit?: null | uint64 @go(EnforcedSampleLimit,*uint64)

	// EnforcedTargetLimit defines a global limit on the number of scraped
	// targets. This overrides any TargetLimit set per ServiceMonitor and/or
	// PodMonitor. It is meant to be used by admins to enforce the TargetLimit to
	// keep the overall number of targets under the desired limit. Note that if a
	// TargetLimit from a ServiceMonitor or PodMonitor is higher, that value is used instead.
	enforcedTargetLimit?: null | uint64 @go(EnforcedTargetLimit,*uint64)

	// InstanceSelector determines which MetricsInstances should be selected
	// for running. Each instance runs its own set of Metrics components,
	// including service discovery, scraping, and remote_write.
	instanceSelector?: null | metav1.#LabelSelector @go(InstanceSelector,*metav1.LabelSelector)

	// InstanceNamespaceSelector is the set of labels that determines which
	// namespaces to watch for MetricsInstances. If not provided, it only checks its own namespace.
	instanceNamespaceSelector?: null | metav1.#LabelSelector @go(InstanceNamespaceSelector,*metav1.LabelSelector)
}

// RemoteWriteSpec defines the remote_write configuration for Prometheus.
#RemoteWriteSpec: {
	// Name of the remote_write queue. Must be unique if specified. The name is
	// used in metrics and logging in order to differentiate queues.
	name?: string @go(Name)

	// URL of the endpoint to send samples to.
	url: string @go(URL)

	// RemoteTimeout is the timeout for requests to the remote_write endpoint.
	remoteTimeout?: string @go(RemoteTimeout)

	// Headers is a set of custom HTTP headers to be sent along with each
	// remote_write request. Be aware that any headers set by Grafana Agent
	// itself can't be overwritten.
	headers?: {[string]: string} @go(Headers,map[string]string)

	// WriteRelabelConfigs holds relabel_configs to relabel samples before they are
	// sent to the remote_write endpoint.
	writeRelabelConfigs?: [...prom_v1.#RelabelConfig] @go(WriteRelabelConfigs,[]prom_v1.RelabelConfig)

	// BasicAuth for the URL.
	basicAuth?: null | prom_v1.#BasicAuth @go(BasicAuth,*prom_v1.BasicAuth)

	// Oauth2 for URL
	oauth2?: null | prom_v1.#OAuth2 @go(OAuth2,*prom_v1.OAuth2)

	// BearerToken used for remote_write.
	bearerToken?: string @go(BearerToken)

	// BearerTokenFile used to read bearer token.
	bearerTokenFile?: string @go(BearerTokenFile)

	// SigV4 configures SigV4-based authentication to the remote_write endpoint.
	// SigV4-based authentication is used if SigV4 is defined, even with an empty object.
	sigv4?: null | #SigV4Config @go(SigV4,*SigV4Config)

	// TLSConfig to use for remote_write.
	tlsConfig?: null | prom_v1.#TLSConfig @go(TLSConfig,*prom_v1.TLSConfig)

	// ProxyURL to proxy requests through. Optional.
	proxyUrl?: string @go(ProxyURL)

	// QueueConfig allows tuning of the remote_write queue parameters.
	queueConfig?: null | #QueueConfig @go(QueueConfig,*QueueConfig)

	// MetadataConfig configures the sending of series metadata to remote storage.
	metadataConfig?: null | #MetadataConfig @go(MetadataConfig,*MetadataConfig)
}

// SigV4Config specifies configuration to perform SigV4 authentication.
#SigV4Config: {
	// Region of the AWS endpoint. If blank, the region from the default
	// credentials chain is used.
	region?: string @go(Region)

	// AccessKey holds the secret of the AWS API access key to use for signing.
	// If not provided, the environment variable AWS_ACCESS_KEY_ID is used.
	accessKey?: null | v1.#SecretKeySelector @go(AccessKey,*v1.SecretKeySelector)

	// SecretKey of the AWS API to use for signing. If blank, the environment
	// variable AWS_SECRET_ACCESS_KEY is used.
	secretKey?: null | v1.#SecretKeySelector @go(SecretKey,*v1.SecretKeySelector)

	// Profile is the named AWS profile to use for authentication.
	profile?: string @go(Profile)

	// RoleARN is the AWS Role ARN to use for authentication, as an alternative
	// for using the AWS API keys.
	roleARN?: string @go(RoleARN)
}

// QueueConfig allows the tuning of remote_write queue_config parameters.
#QueueConfig: {
	// Capacity is the number of samples to buffer per shard before samples start being dropped.
	capacity?: int @go(Capacity)

	// MinShards is the minimum number of shards, i.e., the amount of concurrency.
	minShards?: int @go(MinShards)

	// MaxShards is the maximum number of shards, i.e., the amount of concurrency.
	maxShards?: int @go(MaxShards)

	// MaxSamplesPerSend is the maximum number of samples per send.
	maxSamplesPerSend?: int @go(MaxSamplesPerSend)

	// BatchSendDeadline is the maximum time a sample will wait in the buffer.
	batchSendDeadline?: string @go(BatchSendDeadline)

	// MaxRetries is the maximum number of times to retry a batch on recoverable errors.
	maxRetries?: int @go(MaxRetries)

	// MinBackoff is the initial retry delay. MinBackoff is doubled for every retry.
	minBackoff?: string @go(MinBackoff)

	// MaxBackoff is the maximum retry delay.
	maxBackoff?: string @go(MaxBackoff)

	// RetryOnRateLimit retries requests when encountering rate limits.
	retryOnRateLimit?: bool @go(RetryOnRateLimit)
}

// MetadataConfig configures the sending of series metadata to remote storage.
#MetadataConfig: {
	// Send enables metric metadata to be sent to remote storage.
	send?: bool @go(Send)

	// SendInterval controls how frequently metric metadata is sent to remote storage.
	sendInterval?: string @go(SendInterval)
}

// MetricsInstance controls an individual Metrics instance within a
// Grafana Agent deployment.
#MetricsInstance: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Spec holds the specification of the desired behavior for the Metrics
	// instance.
	spec?: #MetricsInstanceSpec @go(Spec)
}

// MetricsInstanceSpec controls how an individual instance is used to discover PodMonitors.
#MetricsInstanceSpec: {
	// WALTruncateFrequency specifies how frequently to run the WAL truncation process.
	// Higher values cause the WAL to increase and for old series to
	// stay in the WAL longer, but reduces the chance of data loss when
	// remote_write fails for longer than the given frequency.
	walTruncateFrequency?: string @go(WALTruncateFrequency)

	// MinWALTime is the minimum amount of time that series and samples can exist in
	// the WAL before being considered for deletion.
	minWALTime?: string @go(MinWALTime)

	// MaxWALTime is the maximum amount of time that series and samples can exist in
	// the WAL before being forcibly deleted.
	maxWALTime?: string @go(MaxWALTime)

	// RemoteFlushDeadline is the deadline for flushing data when an instance
	// shuts down.
	remoteFlushDeadline?: string @go(RemoteFlushDeadline)

	// WriteStaleOnShutdown writes staleness markers on shutdown for all series.
	writeStaleOnShutdown?: null | bool @go(WriteStaleOnShutdown,*bool)

	// ServiceMonitorSelector determines which ServiceMonitors to select
	// for target discovery.
	serviceMonitorSelector?: null | metav1.#LabelSelector @go(ServiceMonitorSelector,*metav1.LabelSelector)

	// ServiceMonitorNamespaceSelector is the set of labels that determine which
	// namespaces to watch for ServiceMonitor discovery. If nil, it only checks its own namespace.
	serviceMonitorNamespaceSelector?: null | metav1.#LabelSelector @go(ServiceMonitorNamespaceSelector,*metav1.LabelSelector)

	// PodMonitorSelector determines which PodMonitors to selected for target
	// discovery. Experimental.
	podMonitorSelector?: null | metav1.#LabelSelector @go(PodMonitorSelector,*metav1.LabelSelector)

	// PodMonitorNamespaceSelector are the set of labels to determine which
	// namespaces to watch for PodMonitor discovery. If nil, it only checks its own
	// namespace.
	podMonitorNamespaceSelector?: null | metav1.#LabelSelector @go(PodMonitorNamespaceSelector,*metav1.LabelSelector)

	// ProbeSelector determines which Probes to select for target
	// discovery.
	probeSelector?: null | metav1.#LabelSelector @go(ProbeSelector,*metav1.LabelSelector)

	// ProbeNamespaceSelector is the set of labels that determines which namespaces
	// to watch for Probe discovery. If nil, it only checks own namespace.
	probeNamespaceSelector?: null | metav1.#LabelSelector @go(ProbeNamespaceSelector,*metav1.LabelSelector)

	// RemoteWrite controls remote_write settings for this instance.
	remoteWrite?: [...#RemoteWriteSpec] @go(RemoteWrite,[]RemoteWriteSpec)

	// AdditionalScrapeConfigs lets you specify a key of a Secret containing
	// additional Grafana Agent Prometheus scrape configurations. The specified scrape
	// configurations are appended to the configurations generated by
	// Grafana Agent Operator. Specified job configurations must have the
	// form specified in the official Prometheus documentation:
	// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
	// As scrape configs are appended, you must make sure the configuration is still
	// valid. Note that it's possible that this feature will break future
	// upgrades of Grafana Agent. Review both Grafana Agent and
	// Prometheus release notes to ensure that no incompatible scrape configs will
	// break Grafana Agent after the upgrade.
	additionalScrapeConfigs?: null | v1.#SecretKeySelector @go(AdditionalScrapeConfigs,*v1.SecretKeySelector)
}

// MetricsInstanceList is a list of MetricsInstance.
#MetricsInstanceList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)

	// Items is the list of MetricsInstance.
	items: [...null | #MetricsInstance] @go(Items,[]*MetricsInstance)
}
