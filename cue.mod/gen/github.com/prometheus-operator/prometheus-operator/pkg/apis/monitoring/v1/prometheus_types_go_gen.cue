// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1

package v1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	"k8s.io/apimachinery/pkg/util/intstr"
)

#PrometheusesKind:  "Prometheus"
#PrometheusName:    "prometheuses"
#PrometheusKindKey: "prometheus"

// PrometheusInterface is used by Prometheus and PrometheusAgent to share common methods, e.g. config generation.
// +k8s:deepcopy-gen=false
#PrometheusInterface: _

// CommonPrometheusFields are the options available to both the Prometheus server and agent.
// +k8s:deepcopy-gen=true
#CommonPrometheusFields: {
	// PodMetadata configures labels and annotations which are propagated to the Prometheus pods.
	podMetadata?: null | #EmbeddedObjectMetadata @go(PodMetadata,*EmbeddedObjectMetadata)

	// ServiceMonitors to be selected for target discovery. An empty label
	// selector matches all objects. A null label selector matches no objects.
	//
	// If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
	// and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
	// The Prometheus operator will ensure that the Prometheus configuration's
	// Secret exists, but it is the responsibility of the user to provide the raw
	// gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
	// This behavior is *deprecated* and will be removed in the next major version
	// of the custom resource definition. It is recommended to use
	// `spec.additionalScrapeConfigs` instead.
	serviceMonitorSelector?: null | metav1.#LabelSelector @go(ServiceMonitorSelector,*metav1.LabelSelector)

	// Namespaces to match for ServicedMonitors discovery. An empty label selector
	// matches all namespaces. A null label selector matches the current
	// namespace only.
	serviceMonitorNamespaceSelector?: null | metav1.#LabelSelector @go(ServiceMonitorNamespaceSelector,*metav1.LabelSelector)

	// *Experimental* PodMonitors to be selected for target discovery. An empty
	// label selector matches all objects. A null label selector matches no
	// objects.
	//
	// If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
	// and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
	// The Prometheus operator will ensure that the Prometheus configuration's
	// Secret exists, but it is the responsibility of the user to provide the raw
	// gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
	// This behavior is *deprecated* and will be removed in the next major version
	// of the custom resource definition. It is recommended to use
	// `spec.additionalScrapeConfigs` instead.
	podMonitorSelector?: null | metav1.#LabelSelector @go(PodMonitorSelector,*metav1.LabelSelector)

	// Namespaces to match for PodMonitors discovery. An empty label selector
	// matches all namespaces. A null label selector matches the current
	// namespace only.
	podMonitorNamespaceSelector?: null | metav1.#LabelSelector @go(PodMonitorNamespaceSelector,*metav1.LabelSelector)

	// *Experimental* Probes to be selected for target discovery. An empty
	// label selector matches all objects. A null label selector matches no
	// objects.
	//
	// If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
	// and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
	// The Prometheus operator will ensure that the Prometheus configuration's
	// Secret exists, but it is the responsibility of the user to provide the raw
	// gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
	// This behavior is *deprecated* and will be removed in the next major version
	// of the custom resource definition. It is recommended to use
	// `spec.additionalScrapeConfigs` instead.
	probeSelector?: null | metav1.#LabelSelector @go(ProbeSelector,*metav1.LabelSelector)

	// *Experimental* Namespaces to match for Probe discovery. An empty label
	// selector matches all namespaces. A null label selector matches the
	// current namespace only.
	probeNamespaceSelector?: null | metav1.#LabelSelector @go(ProbeNamespaceSelector,*metav1.LabelSelector)

	// *Experimental* ScrapeConfigs to be selected for target discovery. An
	// empty label selector matches all objects. A null label selector matches
	// no objects.
	//
	// If `spec.serviceMonitorSelector`, `spec.podMonitorSelector`, `spec.probeSelector`
	// and `spec.scrapeConfigSelector` are null, the Prometheus configuration is unmanaged.
	// The Prometheus operator will ensure that the Prometheus configuration's
	// Secret exists, but it is the responsibility of the user to provide the raw
	// gzipped Prometheus configuration under the `prometheus.yaml.gz` key.
	// This behavior is *deprecated* and will be removed in the next major version
	// of the custom resource definition. It is recommended to use
	// `spec.additionalScrapeConfigs` instead.
	scrapeConfigSelector?: null | metav1.#LabelSelector @go(ScrapeConfigSelector,*metav1.LabelSelector)

	// Namespaces to match for ScrapeConfig discovery. An empty label selector
	// matches all namespaces. A null label selector matches the current
	// current namespace only.
	scrapeConfigNamespaceSelector?: null | metav1.#LabelSelector @go(ScrapeConfigNamespaceSelector,*metav1.LabelSelector)

	// Version of Prometheus being deployed. The operator uses this information
	// to generate the Prometheus StatefulSet + configuration files.
	//
	// If not specified, the operator assumes the latest upstream version of
	// Prometheus available at the time when the version of the operator was
	// released.
	version?: string @go(Version)

	// When a Prometheus deployment is paused, no actions except for deletion
	// will be performed on the underlying objects.
	paused?: bool @go(Paused)

	// Container image name for Prometheus. If specified, it takes precedence
	// over the `spec.baseImage`, `spec.tag` and `spec.sha` fields.
	//
	// Specifying `spec.version` is still necessary to ensure the Prometheus
	// Operator knows which version of Prometheus is being configured.
	//
	// If neither `spec.image` nor `spec.baseImage` are defined, the operator
	// will use the latest upstream version of Prometheus available at the time
	// when the operator was released.
	//
	// +optional
	image?: null | string @go(Image,*string)

	// Image pull policy for the 'prometheus', 'init-config-reloader' and 'config-reloader' containers.
	// See https://kubernetes.io/docs/concepts/containers/images/#image-pull-policy for more details.
	// +kubebuilder:validation:Enum="";Always;Never;IfNotPresent
	imagePullPolicy?: v1.#PullPolicy @go(ImagePullPolicy)

	// An optional list of references to Secrets in the same namespace
	// to use for pulling images from registries.
	// See http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
	imagePullSecrets?: [...v1.#LocalObjectReference] @go(ImagePullSecrets,[]v1.LocalObjectReference)

	// Number of replicas of each shard to deploy for a Prometheus deployment.
	// `spec.replicas` multiplied by `spec.shards` is the total number of Pods
	// created.
	//
	// Default: 1
	// +optional
	replicas?: null | int32 @go(Replicas,*int32)

	// EXPERIMENTAL: Number of shards to distribute targets onto. `spec.replicas`
	// multiplied by `spec.shards` is the total number of Pods created.
	//
	// Note that scaling down shards will not reshard data onto remaining
	// instances, it must be manually moved. Increasing shards will not reshard
	// data either but it will continue to be available from the same
	// instances. To query globally, use Thanos sidecar and Thanos querier or
	// remote write data to a central location.
	//
	// Sharding is performed on the content of the `__address__` target meta-label
	// for PodMonitors and ServiceMonitors and `__param_target__` for Probes.
	//
	// Default: 1
	// +optional
	shards?: null | int32 @go(Shards,*int32)

	// Name of Prometheus external label used to denote the replica name.
	// The external label will _not_ be added when the field is set to the
	// empty string (`""`).
	//
	// Default: "prometheus_replica"
	// +optional
	replicaExternalLabelName?: null | string @go(ReplicaExternalLabelName,*string)

	// Name of Prometheus external label used to denote the Prometheus instance
	// name. The external label will _not_ be added when the field is set to
	// the empty string (`""`).
	//
	// Default: "prometheus"
	// +optional
	prometheusExternalLabelName?: null | string @go(PrometheusExternalLabelName,*string)

	// Log level for Prometheus and the config-reloader sidecar.
	//+kubebuilder:validation:Enum="";debug;info;warn;error
	logLevel?: string @go(LogLevel)

	// Log format for Log level for Prometheus and the config-reloader sidecar.
	//+kubebuilder:validation:Enum="";logfmt;json
	logFormat?: string @go(LogFormat)

	// Interval between consecutive scrapes.
	//
	// Default: "30s"
	// +kubebuilder:default:="30s"
	scrapeInterval?: #Duration @go(ScrapeInterval)

	// Number of seconds to wait until a scrape request times out.
	scrapeTimeout?: #Duration @go(ScrapeTimeout)

	// The labels to add to any time series or alerts when communicating with
	// external systems (federation, remote storage, Alertmanager).
	// Labels defined by `spec.replicaExternalLabelName` and
	// `spec.prometheusExternalLabelName` take precedence over this list.
	externalLabels?: {[string]: string} @go(ExternalLabels,map[string]string)

	// Enable Prometheus to be used as a receiver for the Prometheus remote
	// write protocol.
	//
	// WARNING: This is not considered an efficient way of ingesting samples.
	// Use it with caution for specific low-volume use cases.
	// It is not suitable for replacing the ingestion via scraping and turning
	// Prometheus into a push-based metrics collection system.
	// For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver
	//
	// It requires Prometheus >= v2.33.0.
	enableRemoteWriteReceiver?: bool @go(EnableRemoteWriteReceiver)

	// Enable access to Prometheus feature flags. By default, no features are enabled.
	//
	// Enabling features which are disabled by default is entirely outside the
	// scope of what the maintainers will support and by doing so, you accept
	// that this behaviour may break at any time without notice.
	//
	// For more information see https://prometheus.io/docs/prometheus/latest/feature_flags/
	enableFeatures?: [...string] @go(EnableFeatures,[]string)

	// The external URL under which the Prometheus service is externally
	// available. This is necessary to generate correct URLs (for instance if
	// Prometheus is accessible behind an Ingress resource).
	externalUrl?: string @go(ExternalURL)

	// The route prefix Prometheus registers HTTP handlers for.
	//
	// This is useful when using `spec.externalURL`, and a proxy is rewriting
	// HTTP routes of a request, and the actual ExternalURL is still true, but
	// the server serves requests under a different route prefix. For example
	// for use with `kubectl proxy`.
	routePrefix?: string @go(RoutePrefix)

	// Storage defines the storage used by Prometheus.
	storage?: null | #StorageSpec @go(Storage,*StorageSpec)

	// Volumes allows the configuration of additional volumes on the output
	// StatefulSet definition. Volumes specified will be appended to other
	// volumes that are generated as a result of StorageSpec objects.
	volumes?: [...v1.#Volume] @go(Volumes,[]v1.Volume)

	// VolumeMounts allows the configuration of additional VolumeMounts.
	//
	// VolumeMounts will be appended to other VolumeMounts in the 'prometheus'
	// container, that are generated as a result of StorageSpec objects.
	volumeMounts?: [...v1.#VolumeMount] @go(VolumeMounts,[]v1.VolumeMount)

	// Defines the configuration of the Prometheus web server.
	web?: null | #PrometheusWebSpec @go(Web,*PrometheusWebSpec)

	// Defines the resources requests and limits of the 'prometheus' container.
	resources?: v1.#ResourceRequirements @go(Resources)

	// Defines on which Nodes the Pods are scheduled.
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)

	// ServiceAccountName is the name of the ServiceAccount to use to run the
	// Prometheus Pods.
	serviceAccountName?: string @go(ServiceAccountName)

	// Secrets is a list of Secrets in the same namespace as the Prometheus
	// object, which shall be mounted into the Prometheus Pods.
	// Each Secret is added to the StatefulSet definition as a volume named `secret-<secret-name>`.
	// The Secrets are mounted into /etc/prometheus/secrets/<secret-name> in the 'prometheus' container.
	secrets?: [...string] @go(Secrets,[]string)

	// ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus
	// object, which shall be mounted into the Prometheus Pods.
	// Each ConfigMap is added to the StatefulSet definition as a volume named `configmap-<configmap-name>`.
	// The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name> in the 'prometheus' container.
	configMaps?: [...string] @go(ConfigMaps,[]string)

	// Defines the Pods' affinity scheduling rules if specified.
	// +optional
	affinity?: null | v1.#Affinity @go(Affinity,*v1.Affinity)

	// Defines the Pods' tolerations if specified.
	// +optional
	tolerations?: [...v1.#Toleration] @go(Tolerations,[]v1.Toleration)

	// Defines the pod's topology spread constraints if specified.
	//+optional
	topologySpreadConstraints?: [...v1.#TopologySpreadConstraint] @go(TopologySpreadConstraints,[]v1.TopologySpreadConstraint)

	// Defines the list of remote write configurations.
	// +optional
	remoteWrite?: [...#RemoteWriteSpec] @go(RemoteWrite,[]RemoteWriteSpec)

	// SecurityContext holds pod-level security attributes and common container settings.
	// This defaults to the default PodSecurityContext.
	// +optional
	securityContext?: null | v1.#PodSecurityContext @go(SecurityContext,*v1.PodSecurityContext)

	// When true, the Prometheus server listens on the loopback address
	// instead of the Pod IP's address.
	listenLocal?: bool @go(ListenLocal)

	// Containers allows injecting additional containers or modifying operator
	// generated containers. This can be used to allow adding an authentication
	// proxy to the Pods or to change the behavior of an operator generated
	// container. Containers described here modify an operator generated
	// container if they share the same name and modifications are done via a
	// strategic merge patch.
	//
	// The names of containers managed by the operator are:
	// * `prometheus`
	// * `config-reloader`
	// * `thanos-sidecar`
	//
	// Overriding containers is entirely outside the scope of what the
	// maintainers will support and by doing so, you accept that this behaviour
	// may break at any time without notice.
	// +optional
	containers?: [...v1.#Container] @go(Containers,[]v1.Container)

	// InitContainers allows injecting initContainers to the Pod definition. Those
	// can be used to e.g.  fetch secrets for injection into the Prometheus
	// configuration from external sources. Any errors during the execution of
	// an initContainer will lead to a restart of the Pod. More info:
	// https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// InitContainers described here modify an operator generated init
	// containers if they share the same name and modifications are done via a
	// strategic merge patch.
	//
	// The names of init container name managed by the operator are:
	// * `init-config-reloader`.
	//
	// Overriding init containers is entirely outside the scope of what the
	// maintainers will support and by doing so, you accept that this behaviour
	// may break at any time without notice.
	// +optional
	initContainers?: [...v1.#Container] @go(InitContainers,[]v1.Container)

	// AdditionalScrapeConfigs allows specifying a key of a Secret containing
	// additional Prometheus scrape configurations. Scrape configurations
	// specified are appended to the configurations generated by the Prometheus
	// Operator. Job configurations specified must have the form as specified
	// in the official Prometheus documentation:
	// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
	// As scrape configs are appended, the user is responsible to make sure it
	// is valid. Note that using this feature may expose the possibility to
	// break upgrades of Prometheus. It is advised to review Prometheus release
	// notes to ensure that no incompatible scrape configs are going to break
	// Prometheus after the upgrade.
	// +optional
	additionalScrapeConfigs?: null | v1.#SecretKeySelector @go(AdditionalScrapeConfigs,*v1.SecretKeySelector)

	// APIServerConfig allows specifying a host and auth methods to access the
	// Kuberntees API server.
	// If null, Prometheus is assumed to run inside of the cluster: it will
	// discover the API servers automatically and use the Pod's CA certificate
	// and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
	// +optional
	apiserverConfig?: null | #APIServerConfig @go(APIServerConfig,*APIServerConfig)

	// Priority class assigned to the Pods.
	priorityClassName?: string @go(PriorityClassName)

	// Port name used for the pods and governing service.
	// Default: "web"
	// +kubebuilder:default:="web"
	portName?: string @go(PortName)

	// When true, ServiceMonitor, PodMonitor and Probe object are forbidden to
	// reference arbitrary files on the file system of the 'prometheus'
	// container.
	// When a ServiceMonitor's endpoint specifies a `bearerTokenFile` value
	// (e.g.  '/var/run/secrets/kubernetes.io/serviceaccount/token'), a
	// malicious target can get access to the Prometheus service account's
	// token in the Prometheus' scrape request. Setting
	// `spec.arbitraryFSAccessThroughSM` to 'true' would prevent the attack.
	// Users should instead provide the credentials using the
	// `spec.bearerTokenSecret` field.
	arbitraryFSAccessThroughSMs?: #ArbitraryFSAccessThroughSMsConfig @go(ArbitraryFSAccessThroughSMs)

	// When true, Prometheus resolves label conflicts by renaming the labels in
	// the scraped data to "exported_<label value>" for all targets created
	// from service and pod monitors.
	// Otherwise the HonorLabels field of the service or pod monitor applies.
	overrideHonorLabels?: bool @go(OverrideHonorLabels)

	// When true, Prometheus ignores the timestamps for all the targets created
	// from service and pod monitors.
	// Otherwise the HonorTimestamps field of the service or pod monitor applies.
	overrideHonorTimestamps?: bool @go(OverrideHonorTimestamps)

	// When true, `spec.namespaceSelector` from all PodMonitor, ServiceMonitor
	// and Probe objects will be ignored. They will only discover targets
	// within the namespace of the PodMonitor, ServiceMonitor and Probe
	// objec.
	ignoreNamespaceSelectors?: bool @go(IgnoreNamespaceSelectors)

	// When not empty, a label will be added to
	//
	// 1. All metrics scraped from `ServiceMonitor`, `PodMonitor`, `Probe` and `ScrapeConfig` objects.
	// 2. All metrics generated from recording rules defined in `PrometheusRule` objects.
	// 3. All alerts generated from alerting rules defined in `PrometheusRule` objects.
	// 4. All vector selectors of PromQL expressions defined in `PrometheusRule` objects.
	//
	// The label will not added for objects referenced in `spec.excludedFromEnforcement`.
	//
	// The label's name is this field's value.
	// The label's value is the namespace of the `ServiceMonitor`,
	// `PodMonitor`, `Probe` or `PrometheusRule` object.
	enforcedNamespaceLabel?: string @go(EnforcedNamespaceLabel)

	// When defined, enforcedSampleLimit specifies a global limit on the number
	// of scraped samples that will be accepted. This overrides any
	// `spec.sampleLimit` set by ServiceMonitor, PodMonitor, Probe objects
	// unless `spec.sampleLimit` is greater than zero and less than than
	// `spec.enforcedSampleLimit`.
	//
	// It is meant to be used by admins to keep the overall number of
	// samples/series under a desired limit.
	//
	// +optional
	enforcedSampleLimit?: null | uint64 @go(EnforcedSampleLimit,*uint64)

	// When defined, enforcedTargetLimit specifies a global limit on the number
	// of scraped targets. The value overrides any `spec.targetLimit` set by
	// ServiceMonitor, PodMonitor, Probe objects unless `spec.targetLimit` is
	// greater than zero and less than `spec.enforcedTargetLimit`.
	//
	// It is meant to be used by admins to to keep the overall number of
	// targets under a desired limit.
	//
	// +optional
	enforcedTargetLimit?: null | uint64 @go(EnforcedTargetLimit,*uint64)

	// When defined, enforcedLabelLimit specifies a global limit on the number
	// of labels per sample. The value overrides any `spec.labelLimit` set by
	// ServiceMonitor, PodMonitor, Probe objects unless `spec.labelLimit` is
	// greater than zero and less than `spec.enforcedLabelLimit`.
	//
	// It requires Prometheus >= v2.27.0.
	//
	// +optional
	enforcedLabelLimit?: null | uint64 @go(EnforcedLabelLimit,*uint64)

	// When defined, enforcedLabelNameLengthLimit specifies a global limit on the length
	// of labels name per sample. The value overrides any `spec.labelNameLengthLimit` set by
	// ServiceMonitor, PodMonitor, Probe objects unless `spec.labelNameLengthLimit` is
	// greater than zero and less than `spec.enforcedLabelNameLengthLimit`.
	//
	// It requires Prometheus >= v2.27.0.
	//
	// +optional
	enforcedLabelNameLengthLimit?: null | uint64 @go(EnforcedLabelNameLengthLimit,*uint64)

	// When not null, enforcedLabelValueLengthLimit defines a global limit on the length
	// of labels value per sample. The value overrides any `spec.labelValueLengthLimit` set by
	// ServiceMonitor, PodMonitor, Probe objects unless `spec.labelValueLengthLimit` is
	// greater than zero and less than `spec.enforcedLabelValueLengthLimit`.
	//
	// It requires Prometheus >= v2.27.0.
	//
	// +optional
	enforcedLabelValueLengthLimit?: null | uint64 @go(EnforcedLabelValueLengthLimit,*uint64)

	// When defined, enforcedBodySizeLimit specifies a global limit on the size
	// of uncompressed response body that will be accepted by Prometheus.
	// Targets responding with a body larger than this many bytes will cause
	// the scrape to fail.
	//
	// It requires Prometheus >= v2.28.0.
	enforcedBodySizeLimit?: #ByteSize @go(EnforcedBodySizeLimit)

	// Minimum number of seconds for which a newly created Pod should be ready
	// without any of its container crashing for it to be considered available.
	// Defaults to 0 (pod will be considered available as soon as it is ready)
	//
	// This is an alpha field from kubernetes 1.22 until 1.24 which requires
	// enabling the StatefulSetMinReadySeconds feature gate.
	//
	// +optional
	minReadySeconds?: null | uint32 @go(MinReadySeconds,*uint32)

	// Optional list of hosts and IPs that will be injected into the Pod's
	// hosts file if specified.
	//
	// +listType=map
	// +listMapKey=ip
	// +optional
	hostAliases?: [...#HostAlias] @go(HostAliases,[]HostAlias)

	// AdditionalArgs allows setting additional arguments for the 'prometheus' container.
	//
	// It is intended for e.g. activating hidden flags which are not supported by
	// the dedicated configuration options yet. The arguments are passed as-is to the
	// Prometheus container which may cause issues if they are invalid or not supported
	// by the given Prometheus version.
	//
	// In case of an argument conflict (e.g. an argument which is already set by the
	// operator itself) or when providing an invalid argument, the reconciliation will
	// fail and an error will be logged.
	//
	// +optional
	additionalArgs?: [...#Argument] @go(AdditionalArgs,[]Argument)

	// Configures compression of the write-ahead log (WAL) using Snappy.
	//
	// WAL compression is enabled by default for Prometheus >= 2.20.0
	//
	// Requires Prometheus v2.11.0 and above.
	//
	// +optional
	walCompression?: null | bool @go(WALCompression,*bool)

	// List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects
	// to be excluded from enforcing a namespace label of origin.
	//
	// It is only applicable if `spec.enforcedNamespaceLabel` set to true.
	//
	// +optional
	excludedFromEnforcement?: [...#ObjectReference] @go(ExcludedFromEnforcement,[]ObjectReference)

	// Use the host's network namespace if true.
	//
	// Make sure to understand the security implications if you want to enable
	// it (https://kubernetes.io/docs/concepts/configuration/overview/).
	//
	// When hostNetwork is enabled, this will set the DNS policy to
	// `ClusterFirstWithHostNet` automatically.
	hostNetwork?: bool @go(HostNetwork)

	// PodTargetLabels are appended to the `spec.podTargetLabels` field of all
	// PodMonitor and ServiceMonitor objects.
	//
	// +optional
	podTargetLabels?: [...string] @go(PodTargetLabels,[]string)

	// EXPERIMENTAL: TracingConfig configures tracing in Prometheus. This is an
	// experimental feature, it may change in any upcoming release in a
	// breaking way.
	//
	// +optional
	tracingConfig?: null | #PrometheusTracingConfig @go(TracingConfig,*PrometheusTracingConfig)

	// BodySizeLimit defines per-scrape on response body size.
	// Only valid in Prometheus versions 2.45.0 and newer.
	//
	// +optional
	bodySizeLimit?: null | #ByteSize @go(BodySizeLimit,*ByteSize)

	// SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
	// Only valid in Prometheus versions 2.45.0 and newer.
	//
	// +optional
	sampleLimit?: null | uint64 @go(SampleLimit,*uint64)

	// TargetLimit defines a limit on the number of scraped targets that will be accepted.
	// Only valid in Prometheus versions 2.45.0 and newer.
	//
	// +optional
	targetLimit?: null | uint64 @go(TargetLimit,*uint64)

	// Per-scrape limit on number of labels that will be accepted for a sample.
	// Only valid in Prometheus versions 2.45.0 and newer.
	//
	// +optional
	labelLimit?: null | uint64 @go(LabelLimit,*uint64)

	// Per-scrape limit on length of labels name that will be accepted for a sample.
	// Only valid in Prometheus versions 2.45.0 and newer.
	//
	// +optional
	labelNameLengthLimit?: null | uint64 @go(LabelNameLengthLimit,*uint64)

	// Per-scrape limit on length of labels value that will be accepted for a sample.
	// Only valid in Prometheus versions 2.45.0 and newer.
	//
	// +optional
	labelValueLengthLimit?: null | uint64 @go(LabelValueLengthLimit,*uint64)
}

// Prometheus defines a Prometheus deployment.
#Prometheus: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Specification of the desired behavior of the Prometheus cluster. More info:
	// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	spec: #PrometheusSpec @go(Spec)

	// Most recent observed status of the Prometheus cluster. Read-only.
	// More info:
	// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	status?: #PrometheusStatus @go(Status)
}

// PrometheusList is a list of Prometheuses.
// +k8s:openapi-gen=true
#PrometheusList: {
	metav1.#TypeMeta

	// Standard list metadata
	// More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
	metadata?: metav1.#ListMeta @go(ListMeta)

	// List of Prometheuses
	items: [...null | #Prometheus] @go(Items,[]*Prometheus)
}

// PrometheusSpec is a specification of the desired behavior of the Prometheus cluster. More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +k8s:openapi-gen=true
#PrometheusSpec: {
	#CommonPrometheusFields

	// *Deprecated: use 'spec.image' instead.*
	baseImage?: string @go(BaseImage)

	// *Deprecated: use 'spec.image' instead. The image's tag can be specified
	// as part of the image name.*
	tag?: string @go(Tag)

	// *Deprecated: use 'spec.image' instead. The image's digest can be
	// specified as part of the image name.*
	sha?: string @go(SHA)

	// How long to retain the Prometheus data.
	//
	// Default: "24h" if `spec.retention` and `spec.retentionSize` are empty.
	retention?: #Duration @go(Retention)

	// Maximum number of bytes used by the Prometheus data.
	retentionSize?: #ByteSize @go(RetentionSize)

	// When true, the Prometheus compaction is disabled.
	disableCompaction?: bool @go(DisableCompaction)

	// Defines the configuration of the Prometheus rules' engine.
	rules?: #Rules @go(Rules)

	// Defines the list of PrometheusRule objects to which the namespace label
	// enforcement doesn't apply.
	// This is only relevant when `spec.enforcedNamespaceLabel` is set to true.
	// *Deprecated: use `spec.excludedFromEnforcement` instead.*
	// +optional
	prometheusRulesExcludedFromEnforce?: [...#PrometheusRuleExcludeConfig] @go(PrometheusRulesExcludedFromEnforce,[]PrometheusRuleExcludeConfig)

	// PrometheusRule objects to be selected for rule evaluation. An empty
	// label selector matches all objects. A null label selector matches no
	// objects.
	// +optional
	ruleSelector?: null | metav1.#LabelSelector @go(RuleSelector,*metav1.LabelSelector)

	// Namespaces to match for PrometheusRule discovery. An empty label selector
	// matches all namespaces. A null label selector matches the current
	// namespace only.
	// +optional
	ruleNamespaceSelector?: null | metav1.#LabelSelector @go(RuleNamespaceSelector,*metav1.LabelSelector)

	// QuerySpec defines the configuration of the Promethus query service.
	// +optional
	query?: null | #QuerySpec @go(Query,*QuerySpec)

	// Defines the settings related to Alertmanager.
	// +optional
	alerting?: null | #AlertingSpec @go(Alerting,*AlertingSpec)

	// AdditionalAlertRelabelConfigs specifies a key of a Secret containing
	// additional Prometheus alert relabel configurations. The alert relabel
	// configurations are appended to the configuration generated by the
	// Prometheus Operator. They must be formatted according to the official
	// Prometheus documentation:
	//
	// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs
	//
	// The user is responsible for making sure that the configurations are valid
	//
	// Note that using this feature may expose the possibility to break
	// upgrades of Prometheus. It is advised to review Prometheus release notes
	// to ensure that no incompatible alert relabel configs are going to break
	// Prometheus after the upgrade.
	// +optional
	additionalAlertRelabelConfigs?: null | v1.#SecretKeySelector @go(AdditionalAlertRelabelConfigs,*v1.SecretKeySelector)

	// AdditionalAlertManagerConfigs specifies a key of a Secret containing
	// additional Prometheus Alertmanager configurations. The Alertmanager
	// configurations are appended to the configuration generated by the
	// Prometheus Operator. They must be formatted according to the official
	// Prometheus documentation:
	//
	// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config
	//
	// The user is responsible for making sure that the configurations are valid
	//
	// Note that using this feature may expose the possibility to break
	// upgrades of Prometheus. It is advised to review Prometheus release notes
	// to ensure that no incompatible AlertManager configs are going to break
	// Prometheus after the upgrade.
	// +optional
	additionalAlertManagerConfigs?: null | v1.#SecretKeySelector @go(AdditionalAlertManagerConfigs,*v1.SecretKeySelector)

	// Defines the list of remote read configurations.
	// +optional
	remoteRead?: [...#RemoteReadSpec] @go(RemoteRead,[]RemoteReadSpec)

	// Defines the configuration of the optional Thanos sidecar.
	//
	// This section is experimental, it may change significantly without
	// deprecation notice in any release.
	// +optional
	thanos?: null | #ThanosSpec @go(Thanos,*ThanosSpec)

	// queryLogFile specifies where the file to which PromQL queries are logged.
	//
	// If the filename has an empty path, e.g. 'query.log', The Prometheus Pods
	// will mount the file into an emptyDir volume at `/var/log/prometheus`.
	// If a full path is provided, e.g. '/var/log/prometheus/query.log', you
	// must mount a volume in the specified directory and it must be writable.
	// This is because the prometheus container runs with a read-only root
	// filesystem for security reasons.
	// Alternatively, the location can be set to a standard I/O stream, e.g.
	// `/dev/stdout`, to log query information to the default Prometheus log
	// stream.
	queryLogFile?: string @go(QueryLogFile)

	// AllowOverlappingBlocks enables vertical compaction and vertical query
	// merge in Prometheus.
	//
	// *Deprecated: this flag has no effect for Prometheus >= 2.39.0 where overlapping blocks are enabled by default.*
	allowOverlappingBlocks?: bool @go(AllowOverlappingBlocks)

	// Exemplars related settings that are runtime reloadable.
	// It requires to enable the `exemplar-storage` feature flag to be effective.
	// +optional
	exemplars?: null | #Exemplars @go(Exemplars,*Exemplars)

	// Interval between rule evaluations.
	// Default: "30s"
	// +kubebuilder:default:="30s"
	evaluationInterval?: #Duration @go(EvaluationInterval)

	// Enables access to the Prometheus web admin API.
	//
	// WARNING: Enabling the admin APIs enables mutating endpoints, to delete data,
	// shutdown Prometheus, and more. Enabling this should be done with care and the
	// user is advised to add additional authentication authorization via a proxy to
	// ensure only clients authorized to perform these actions can do so.
	//
	// For more information:
	// https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis
	enableAdminAPI?: bool @go(EnableAdminAPI)

	// Defines the runtime reloadable configuration of the timeseries database
	// (TSDB).
	tsdb?: #TSDBSpec @go(TSDB)
}

#PrometheusTracingConfig: {
	// Client used to export the traces. Supported values are `http` or `grpc`.
	//+kubebuilder:validation:Enum=http;grpc
	// +optional
	clientType?: null | string @go(ClientType,*string)

	// Endpoint to send the traces to. Should be provided in format <host>:<port>.
	// +kubebuilder:validation:MinLength:=1
	// +required
	endpoint: string @go(Endpoint)

	// Sets the probability a given trace will be sampled. Must be a float from 0 through 1.
	// +optional
	samplingFraction?: null | resource.#Quantity @go(SamplingFraction,*resource.Quantity)

	// If disabled, the client will use a secure connection.
	// +optional
	insecure?: null | bool @go(Insecure,*bool)

	// Key-value pairs to be used as headers associated with gRPC or HTTP requests.
	// +optional
	headers: {[string]: string} @go(Headers,map[string]string)

	// Compression key for supported compression types. The only supported value is `gzip`.
	//+kubebuilder:validation:Enum=gzip
	// +optional
	compression?: null | string @go(Compression,*string)

	// Maximum time the exporter will wait for each batch export.
	// +optional
	timeout?: null | #Duration @go(Timeout,*Duration)

	// TLS Config to use when sending traces.
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)
}

// PrometheusStatus is the most recent observed status of the Prometheus cluster.
// More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +k8s:openapi-gen=true
#PrometheusStatus: {
	// Represents whether any actions on the underlying managed objects are
	// being performed. Only delete actions will be performed.
	paused: bool @go(Paused)

	// Total number of non-terminated pods targeted by this Prometheus deployment
	// (their labels match the selector).
	replicas: int32 @go(Replicas)

	// Total number of non-terminated pods targeted by this Prometheus deployment
	// that have the desired version spec.
	updatedReplicas: int32 @go(UpdatedReplicas)

	// Total number of available pods (ready for at least minReadySeconds)
	// targeted by this Prometheus deployment.
	availableReplicas: int32 @go(AvailableReplicas)

	// Total number of unavailable pods targeted by this Prometheus deployment.
	unavailableReplicas: int32 @go(UnavailableReplicas)

	// The current state of the Prometheus deployment.
	// +listType=map
	// +listMapKey=type
	// +optional
	conditions?: [...#Condition] @go(Conditions,[]Condition)

	// The list has one entry per shard. Each entry provides a summary of the shard status.
	// +listType=map
	// +listMapKey=shardID
	// +optional
	shardStatuses?: [...#ShardStatus] @go(ShardStatuses,[]ShardStatus)
}

// AlertingSpec defines parameters for alerting configuration of Prometheus servers.
// +k8s:openapi-gen=true
#AlertingSpec: {
	// AlertmanagerEndpoints Prometheus should fire alerts against.
	alertmanagers: [...#AlertmanagerEndpoints] @go(Alertmanagers,[]AlertmanagerEndpoints)
}

// StorageSpec defines the configured storage for a group Prometheus servers.
// If no storage option is specified, then by default an [EmptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir) will be used.
//
// If multiple storage options are specified, priority will be given as follows:
//  1. emptyDir
//  2. ephemeral
//  3. volumeClaimTemplate
//
// +k8s:openapi-gen=true
#StorageSpec: {
	// *Deprecated: subPath usage will be removed in a future release.*
	disableMountSubPath?: bool @go(DisableMountSubPath)

	// EmptyDirVolumeSource to be used by the StatefulSet.
	// If specified, it takes precedence over `ephemeral` and `volumeClaimTemplate`.
	// More info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
	emptyDir?: null | v1.#EmptyDirVolumeSource @go(EmptyDir,*v1.EmptyDirVolumeSource)

	// EphemeralVolumeSource to be used by the StatefulSet.
	// This is a beta field in k8s 1.21 and GA in 1.15.
	// For lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
	// More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
	ephemeral?: null | v1.#EphemeralVolumeSource @go(Ephemeral,*v1.EphemeralVolumeSource)

	// Defines the PVC spec to be used by the Prometheus StatefulSets.
	// The easiest way to use a volume that cannot be automatically provisioned
	// is to use a label selector alongside manually created PersistentVolumes.
	volumeClaimTemplate?: #EmbeddedPersistentVolumeClaim @go(VolumeClaimTemplate)
}

// QuerySpec defines the query command line flags when starting Prometheus.
// +k8s:openapi-gen=true
#QuerySpec: {
	// The delta difference allowed for retrieving metrics during expression evaluations.
	// +optional
	lookbackDelta?: null | string @go(LookbackDelta,*string)

	// Number of concurrent queries that can be run at once.
	// +kubebuilder:validation:Minimum:=1
	// +optional
	maxConcurrency?: null | int32 @go(MaxConcurrency,*int32)

	// Maximum number of samples a single query can load into memory. Note that
	// queries will fail if they would load more samples than this into memory,
	// so this also limits the number of samples a query can return.
	// +optional
	maxSamples?: null | int32 @go(MaxSamples,*int32)

	// Maximum time a query may take before being aborted.
	// +optional
	timeout?: null | #Duration @go(Timeout,*Duration)
}

// PrometheusWebSpec defines the configuration of the Prometheus web server.
// +k8s:openapi-gen=true
#PrometheusWebSpec: {
	#WebConfigFileFields

	// The prometheus web page title.
	// +optional
	pageTitle?: null | string @go(PageTitle,*string)

	// Defines the maximum number of simultaneous connections
	// A zero value means that Prometheus doesn't accept any incoming connection.
	// +kubebuilder:validation:Minimum:=0
	// +optional
	maxConnections?: null | int32 @go(MaxConnections,*int32)
}

// ThanosSpec defines the configuration of the Thanos sidecar.
// +k8s:openapi-gen=true
#ThanosSpec: {
	// Container image name for Thanos. If specified, it takes precedence over
	// the `spec.thanos.baseImage`, `spec.thanos.tag` and `spec.thanos.sha`
	// fields.
	//
	// Specifying `spec.thanos.version` is still necessary to ensure the
	// Prometheus Operator knows which version of Thanos is being configured.
	//
	// If neither `spec.thanos.image` nor `spec.thanos.baseImage` are defined,
	// the operator will use the latest upstream version of Thanos available at
	// the time when the operator was released.
	//
	// +optional
	image?: null | string @go(Image,*string)

	// Version of Thanos being deployed. The operator uses this information
	// to generate the Prometheus StatefulSet + configuration files.
	//
	// If not specified, the operator assumes the latest upstream release of
	// Thanos available at the time when the version of the operator was
	// released.
	//
	// +optional
	version?: null | string @go(Version,*string)

	// *Deprecated: use 'image' instead. The image's tag can be specified as
	// part of the image name.*
	// +optional
	tag?: null | string @go(Tag,*string)

	// *Deprecated: use 'image' instead.  The image digest can be specified
	// as part of the image name.*
	// +optional
	sha?: null | string @go(SHA,*string)

	// *Deprecated: use 'image' instead.*
	// +optional
	baseImage?: null | string @go(BaseImage,*string)

	// Defines the resources requests and limits of the Thanos sidecar.
	resources?: v1.#ResourceRequirements @go(Resources)

	// Defines the Thanos sidecar's configuration to upload TSDB blocks to object storage.
	//
	// More info: https://thanos.io/tip/thanos/storage.md/
	//
	// objectStorageConfigFile takes precedence over this field.
	// +optional
	objectStorageConfig?: null | v1.#SecretKeySelector @go(ObjectStorageConfig,*v1.SecretKeySelector)

	// Defines the Thanos sidecar's configuration file to upload TSDB blocks to object storage.
	//
	// More info: https://thanos.io/tip/thanos/storage.md/
	//
	// This field takes precedence over objectStorageConfig.
	// +optional
	objectStorageConfigFile?: null | string @go(ObjectStorageConfigFile,*string)

	// *Deprecated: use `grpcListenLocal` and `httpListenLocal` instead.*
	listenLocal?: bool @go(ListenLocal)

	// When true, the Thanos sidecar listens on the loopback interface instead
	// of the Pod IP's address for the gRPC endpoints.
	//
	// It has no effect if `listenLocal` is true.
	grpcListenLocal?: bool @go(GRPCListenLocal)

	// When true, the Thanos sidecar listens on the loopback interface instead
	// of the Pod IP's address for the HTTP endpoints.
	//
	// It has no effect if `listenLocal` is true.
	httpListenLocal?: bool @go(HTTPListenLocal)

	// Defines the tracing configuration for the Thanos sidecar.
	//
	// More info: https://thanos.io/tip/thanos/tracing.md/
	//
	// This is an experimental feature, it may change in any upcoming release
	// in a breaking way.
	//
	// tracingConfigFile takes precedence over this field.
	// +optional
	tracingConfig?: null | v1.#SecretKeySelector @go(TracingConfig,*v1.SecretKeySelector)

	// Defines the tracing configuration file for the Thanos sidecar.
	//
	// More info: https://thanos.io/tip/thanos/tracing.md/
	//
	// This is an experimental feature, it may change in any upcoming release
	// in a breaking way.
	//
	// This field takes precedence over tracingConfig.
	tracingConfigFile?: string @go(TracingConfigFile)

	// Configures the TLS parameters for the gRPC server providing the StoreAPI.
	//
	// Note: Currently only the `caFile`, `certFile`, and `keyFile` fields are supported.
	//
	// +optional
	grpcServerTlsConfig?: null | #TLSConfig @go(GRPCServerTLSConfig,*TLSConfig)

	// Log level for the Thanos sidecar.
	//+kubebuilder:validation:Enum="";debug;info;warn;error
	logLevel?: string @go(LogLevel)

	// Log format for the Thanos sidecar.
	//+kubebuilder:validation:Enum="";logfmt;json
	logFormat?: string @go(LogFormat)

	// Defines the start of time range limit served by the Thanos sidecar's StoreAPI.
	// The field's value should be a constant time in RFC3339 format or a time
	// duration relative to current time, such as -1d or 2h45m. Valid duration
	// units are ms, s, m, h, d, w, y.
	minTime?: string @go(MinTime)

	// BlockDuration controls the size of TSDB blocks produced by Prometheus.
	// The default value is 2h to match the upstream Prometheus defaults.
	//
	// WARNING: Changing the block duration can impact the performance and
	// efficiency of the entire Prometheus/Thanos stack due to how it interacts
	// with memory and Thanos compactors. It is recommended to keep this value
	// set to a multiple of 120 times your longest scrape or rule interval. For
	// example, 30s * 120 = 1h.
	//
	// +kubebuilder:default:="2h"
	blockSize?: #Duration @go(BlockDuration)

	// ReadyTimeout is the maximum time that the Thanos sidecar will wait for
	// Prometheus to start.
	readyTimeout?: #Duration @go(ReadyTimeout)

	// How often to retrieve the Prometheus configuration.
	getConfigInterval?: #Duration @go(GetConfigInterval)

	// Maximum time to wait when retrieving the Prometheus configuration.
	getConfigTimeout?: #Duration @go(GetConfigTimeout)

	// VolumeMounts allows configuration of additional VolumeMounts for Thanos.
	// VolumeMounts specified will be appended to other VolumeMounts in the
	// 'thanos-sidecar' container.
	// +optional
	volumeMounts?: [...v1.#VolumeMount] @go(VolumeMounts,[]v1.VolumeMount)

	// AdditionalArgs allows setting additional arguments for the Thanos container.
	// The arguments are passed as-is to the Thanos container which may cause issues
	// if they are invalid or not supported the given Thanos version.
	// In case of an argument conflict (e.g. an argument which is already set by the
	// operator itself) or when providing an invalid argument, the reconciliation will
	// fail and an error will be logged.
	// +optional
	additionalArgs?: [...#Argument] @go(AdditionalArgs,[]Argument)
}

// RemoteWriteSpec defines the configuration to write samples from Prometheus
// to a remote endpoint.
// +k8s:openapi-gen=true
#RemoteWriteSpec: {
	// The URL of the endpoint to send samples to.
	url: string @go(URL)

	// The name of the remote write queue, it must be unique if specified. The
	// name is used in metrics and logging in order to differentiate queues.
	//
	// It requires Prometheus >= v2.15.0.
	//
	name?: string @go(Name)

	// Enables sending of exemplars over remote write. Note that
	// exemplar-storage itself must be enabled using the `spec.enableFeature`
	// option for exemplars to be scraped in the first place.
	//
	// It requires Prometheus >= v2.27.0.
	//
	// +optional
	sendExemplars?: null | bool @go(SendExemplars,*bool)

	// Enables sending of native histograms, also known as sparse histograms
	// over remote write.
	//
	// It requires Prometheus >= v2.40.0.
	//
	// +optional
	sendNativeHistograms?: null | bool @go(SendNativeHistograms,*bool)

	// Timeout for requests to the remote write endpoint.
	remoteTimeout?: #Duration @go(RemoteTimeout)

	// Custom HTTP headers to be sent along with each remote write request.
	// Be aware that headers that are set by Prometheus itself can't be overwritten.
	//
	// It requires Prometheus >= v2.25.0.
	//
	// +optional
	headers?: {[string]: string} @go(Headers,map[string]string)

	// The list of remote write relabel configurations.
	// +optional
	writeRelabelConfigs?: [...#RelabelConfig] @go(WriteRelabelConfigs,[]RelabelConfig)

	// OAuth2 configuration for the URL.
	//
	// It requires Prometheus >= v2.27.0.
	//
	// Cannot be set at the same time as `sigv4`, `authorization`, or `basicAuth`.
	// +optional
	oauth2?: null | #OAuth2 @go(OAuth2,*OAuth2)

	// BasicAuth configuration for the URL.
	//
	// Cannot be set at the same time as `sigv4`, `authorization`, or `oauth2`.
	//
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// File from which to read bearer token for the URL.
	//
	// *Deprecated: this will be removed in a future release. Prefer using `authorization`.*
	bearerTokenFile?: string @go(BearerTokenFile)

	// Authorization section for the URL.
	//
	// It requires Prometheus >= v2.26.0.
	//
	// Cannot be set at the same time as `sigv4`, `basicAuth`, or `oauth2`.
	//
	// +optional
	authorization?: null | #Authorization @go(Authorization,*Authorization)

	// Sigv4 allows to configures AWS's Signature Verification 4 for the URL.
	//
	// It requires Prometheus >= v2.26.0.
	//
	// Cannot be set at the same time as `authorization`, `basicAuth`, or `oauth2`.
	//
	// +optional
	sigv4?: null | #Sigv4 @go(Sigv4,*Sigv4)

	// *Warning: this field shouldn't be used because the token value appears
	// in clear-text. Prefer using `authorization`.*
	//
	// *Deprecated: this will be removed in a future release.*
	bearerToken?: string @go(BearerToken)

	// TLS Config to use for the URL.
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	// Optional ProxyURL.
	proxyUrl?: string @go(ProxyURL)

	// QueueConfig allows tuning of the remote write queue parameters.
	// +optional
	queueConfig?: null | #QueueConfig @go(QueueConfig,*QueueConfig)

	// MetadataConfig configures the sending of series metadata to the remote storage.
	// +optional
	metadataConfig?: null | #MetadataConfig @go(MetadataConfig,*MetadataConfig)
}

// QueueConfig allows the tuning of remote write's queue_config parameters.
// This object is referenced in the RemoteWriteSpec object.
// +k8s:openapi-gen=true
#QueueConfig: {
	// Capacity is the number of samples to buffer per shard before we start
	// dropping them.
	capacity?: int @go(Capacity)

	// MinShards is the minimum number of shards, i.e. amount of concurrency.
	minShards?: int @go(MinShards)

	// MaxShards is the maximum number of shards, i.e. amount of concurrency.
	maxShards?: int @go(MaxShards)

	// MaxSamplesPerSend is the maximum number of samples per send.
	maxSamplesPerSend?: int @go(MaxSamplesPerSend)

	// BatchSendDeadline is the maximum time a sample will wait in buffer.
	batchSendDeadline?: string @go(BatchSendDeadline)

	// MaxRetries is the maximum number of times to retry a batch on recoverable errors.
	maxRetries?: int @go(MaxRetries)

	// MinBackoff is the initial retry delay. Gets doubled for every retry.
	minBackoff?: string @go(MinBackoff)

	// MaxBackoff is the maximum retry delay.
	maxBackoff?: string @go(MaxBackoff)

	// Retry upon receiving a 429 status code from the remote-write storage.
	// This is experimental feature and might change in the future.
	retryOnRateLimit?: bool @go(RetryOnRateLimit)
}

// Sigv4 optionally configures AWS's Signature Verification 4 signing process to
// sign requests.
// +k8s:openapi-gen=true
#Sigv4: {
	// Region is the AWS region. If blank, the region from the default credentials chain used.
	region?: string @go(Region)

	// AccessKey is the AWS API key. If not specified, the environment variable
	// `AWS_ACCESS_KEY_ID` is used.
	// +optional
	accessKey?: null | v1.#SecretKeySelector @go(AccessKey,*v1.SecretKeySelector)

	// SecretKey is the AWS API secret. If not specified, the environment
	// variable `AWS_SECRET_ACCESS_KEY` is used.
	// +optional
	secretKey?: null | v1.#SecretKeySelector @go(SecretKey,*v1.SecretKeySelector)

	// Profile is the named AWS profile used to authenticate.
	profile?: string @go(Profile)

	// RoleArn is the named AWS profile used to authenticate.
	roleArn?: string @go(RoleArn)
}

// RemoteReadSpec defines the configuration for Prometheus to read back samples
// from a remote endpoint.
// +k8s:openapi-gen=true
#RemoteReadSpec: {
	// The URL of the endpoint to query from.
	url: string @go(URL)

	// The name of the remote read queue, it must be unique if specified. The
	// name is used in metrics and logging in order to differentiate read
	// configurations.
	//
	// It requires Prometheus >= v2.15.0.
	//
	name?: string @go(Name)

	// An optional list of equality matchers which have to be present
	// in a selector to query the remote read endpoint.
	// +optional
	requiredMatchers?: {[string]: string} @go(RequiredMatchers,map[string]string)

	// Timeout for requests to the remote read endpoint.
	remoteTimeout?: #Duration @go(RemoteTimeout)

	// Custom HTTP headers to be sent along with each remote read request.
	// Be aware that headers that are set by Prometheus itself can't be overwritten.
	// Only valid in Prometheus versions 2.26.0 and newer.
	// +optional
	headers?: {[string]: string} @go(Headers,map[string]string)

	// Whether reads should be made for queries for time ranges that
	// the local storage should have complete data for.
	readRecent?: bool @go(ReadRecent)

	// OAuth2 configuration for the URL.
	//
	// It requires Prometheus >= v2.27.0.
	//
	// Cannot be set at the same time as `authorization`, or `basicAuth`.
	//
	// +optional
	oauth2?: null | #OAuth2 @go(OAuth2,*OAuth2)

	// BasicAuth configuration for the URL.
	//
	// Cannot be set at the same time as `authorization`, or `oauth2`.
	//
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// File from which to read the bearer token for the URL.
	//
	// *Deprecated: this will be removed in a future release. Prefer using `authorization`.*
	bearerTokenFile?: string @go(BearerTokenFile)

	// Authorization section for the URL.
	//
	// It requires Prometheus >= v2.26.0.
	//
	// Cannot be set at the same time as `basicAuth`, or `oauth2`.
	//
	// +optional
	authorization?: null | #Authorization @go(Authorization,*Authorization)

	// *Warning: this field shouldn't be used because the token value appears
	// in clear-text. Prefer using `authorization`.*
	//
	// *Deprecated: this will be removed in a future release.*
	bearerToken?: string @go(BearerToken)

	// TLS Config to use for the URL.
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	// Optional ProxyURL.
	proxyUrl?: string @go(ProxyURL)

	// Configure whether HTTP requests follow HTTP 3xx redirects.
	//
	// It requires Prometheus >= v2.26.0.
	//
	// +optional
	followRedirects?: null | bool @go(FollowRedirects,*bool)

	// Whether to use the external labels as selectors for the remote read endpoint.
	//
	// It requires Prometheus >= v2.34.0.
	//
	// +optional
	filterExternalLabels?: null | bool @go(FilterExternalLabels,*bool)
}

// RelabelConfig allows dynamic rewriting of the label set for targets, alerts,
// scraped samples and remote write samples.
//
// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
//
// +k8s:openapi-gen=true
#RelabelConfig: {
	// The source labels select values from existing labels. Their content is
	// concatenated using the configured Separator and matched against the
	// configured regular expression.
	//
	// +optional
	sourceLabels?: [...#LabelName] @go(SourceLabels,[]LabelName)

	// Separator is the string between concatenated SourceLabels.
	separator?: string @go(Separator)

	// Label to which the resulting string is written in a replacement.
	//
	// It is mandatory for `Replace`, `HashMod`, `Lowercase`, `Uppercase`,
	// `KeepEqual` and `DropEqual` actions.
	//
	// Regex capture groups are available.
	targetLabel?: string @go(TargetLabel)

	// Regular expression against which the extracted value is matched.
	regex?: string @go(Regex)

	// Modulus to take of the hash of the source label values.
	//
	// Only applicable when the action is `HashMod`.
	modulus?: uint64 @go(Modulus)

	// Replacement value against which a Replace action is performed if the
	// regular expression matches.
	//
	// Regex capture groups are available.
	replacement?: string @go(Replacement)

	// Action to perform based on the regex matching.
	//
	// `Uppercase` and `Lowercase` actions require Prometheus >= v2.36.0.
	// `DropEqual` and `KeepEqual` actions require Prometheus >= v2.41.0.
	//
	// Default: "Replace"
	//
	// +kubebuilder:validation:Enum=replace;Replace;keep;Keep;drop;Drop;hashmod;HashMod;labelmap;LabelMap;labeldrop;LabelDrop;labelkeep;LabelKeep;lowercase;Lowercase;uppercase;Uppercase;keepequal;KeepEqual;dropequal;DropEqual
	// +kubebuilder:default=replace
	action?: string @go(Action)
}

// APIServerConfig defines how the Prometheus server connects to the Kubernetes API server.
//
// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config
//
// +k8s:openapi-gen=true
#APIServerConfig: {
	// Kubernetes API address consisting of a hostname or IP address followed
	// by an optional port number.
	host: string @go(Host)

	// BasicAuth configuration for the API server.
	//
	// Cannot be set at the same time as `authorization`, `bearerToken`, or
	// `bearerTokenFile`.
	//
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// File to read bearer token for accessing apiserver.
	//
	// Cannot be set at the same time as `basicAuth`, `authorization`, or `bearerToken`.
	//
	// *Deprecated: this will be removed in a future release. Prefer using `authorization`.*
	bearerTokenFile?: string @go(BearerTokenFile)

	// TLS Config to use for the API server.
	//
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	// Authorization section for the API server.
	//
	// Cannot be set at the same time as `basicAuth`, `bearerToken`, or
	// `bearerTokenFile`.
	//
	// +optional
	authorization?: null | #Authorization @go(Authorization,*Authorization)

	// *Warning: this field shouldn't be used because the token value appears
	// in clear-text. Prefer using `authorization`.*
	//
	// *Deprecated: this will be removed in a future release.*
	bearerToken?: string @go(BearerToken)
}

// AlertmanagerEndpoints defines a selection of a single Endpoints object
// containing Alertmanager IPs to fire alerts against.
// +k8s:openapi-gen=true
#AlertmanagerEndpoints: {
	// Namespace of the Endpoints object.
	namespace: string @go(Namespace)

	// Name of the Endpoints object in the namespace.
	name: string @go(Name)

	// Port on which the Alertmanager API is exposed.
	port: intstr.#IntOrString @go(Port)

	// Scheme to use when firing alerts.
	scheme?: string @go(Scheme)

	// Prefix for the HTTP path alerts are pushed to.
	pathPrefix?: string @go(PathPrefix)

	// TLS Config to use for Alertmanager.
	//
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	// BasicAuth configuration for Alertmanager.
	//
	// Cannot be set at the same time as `bearerTokenFile`, or `authorization`.
	//
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// File to read bearer token for Alertmanager.
	//
	// Cannot be set at the same time as `basicAuth`, or `authorization`.
	//
	// *Deprecated: this will be removed in a future release. Prefer using `authorization`.*
	bearerTokenFile?: string @go(BearerTokenFile)

	// Authorization section for Alertmanager.
	//
	// Cannot be set at the same time as `basicAuth`, or `bearerTokenFile`.
	//
	// +optional
	authorization?: null | #SafeAuthorization @go(Authorization,*SafeAuthorization)

	// Version of the Alertmanager API that Prometheus uses to send alerts.
	// It can be "v1" or "v2".
	apiVersion?: string @go(APIVersion)

	// Timeout is a per-target Alertmanager timeout when pushing alerts.
	//
	// +optional
	timeout?: null | #Duration @go(Timeout,*Duration)

	// Whether to enable HTTP2.
	//
	// +optional
	enableHttp2?: null | bool @go(EnableHttp2,*bool)
}

// +k8s:openapi-gen=true
#Rules: {
	// Defines the parameters of the Prometheus rules' engine.
	//
	// Any update to these parameters trigger a restart of the pods.
	alert?: #RulesAlert @go(Alert)
}

// +k8s:openapi-gen=true
#RulesAlert: {
	// Max time to tolerate prometheus outage for restoring 'for' state of
	// alert.
	forOutageTolerance?: string @go(ForOutageTolerance)

	// Minimum duration between alert and restored 'for' state.
	//
	// This is maintained only for alerts with a configured 'for' time greater
	// than the grace period.
	forGracePeriod?: string @go(ForGracePeriod)

	// Minimum amount of time to wait before resending an alert to
	// Alertmanager.
	resendDelay?: string @go(ResendDelay)
}

// MetadataConfig configures the sending of series metadata to the remote storage.
//
// +k8s:openapi-gen=true
#MetadataConfig: {
	// Defines whether metric metadata is sent to the remote storage or not.
	send?: bool @go(Send)

	// Defines how frequently metric metadata is sent to the remote storage.
	sendInterval?: #Duration @go(SendInterval)
}

#ShardStatus: {
	// Identifier of the shard.
	// +required
	shardID: string @go(ShardID)

	// Total number of pods targeted by this shard.
	replicas: int32 @go(Replicas)

	// Total number of non-terminated pods targeted by this shard
	// that have the desired spec.
	updatedReplicas: int32 @go(UpdatedReplicas)

	// Total number of available pods (ready for at least minReadySeconds)
	// targeted by this shard.
	availableReplicas: int32 @go(AvailableReplicas)

	// Total number of unavailable pods targeted by this shard.
	unavailableReplicas: int32 @go(UnavailableReplicas)
}

#TSDBSpec: {
	// Configures how old an out-of-order/out-of-bounds sample can be with
	// respect to the TSDB max time.
	//
	// An out-of-order/out-of-bounds sample is ingested into the TSDB as long as
	// the timestamp of the sample is >= (TSDB.MaxTime - outOfOrderTimeWindow).
	//
	// Out of order ingestion is an experimental feature.
	//
	// It requires Prometheus >= v2.39.0.
	outOfOrderTimeWindow?: #Duration @go(OutOfOrderTimeWindow)
}

#Exemplars: {
	// Maximum number of exemplars stored in memory for all series.
	//
	// exemplar-storage itself must be enabled using the `spec.enableFeature`
	// option for exemplars to be scraped in the first place.
	//
	// If not set, Prometheus uses its default value. A value of zero or less
	// than zero disables the storage.
	//
	// +optional
	maxSize?: null | int64 @go(MaxSize,*int64)
}

// SafeAuthorization specifies a subset of the Authorization struct, that is
// safe for use because it doesn't provide access to the Prometheus container's
// filesystem.
//
// +k8s:openapi-gen=true
#SafeAuthorization: {
	// Defines the authentication type. The value is case-insensitive.
	//
	// "Basic" is not a supported value.
	//
	// Default: "Bearer"
	type?: string @go(Type)

	// Selects a key of a Secret in the namespace that contains the credentials for authentication.
	credentials?: null | v1.#SecretKeySelector @go(Credentials,*v1.SecretKeySelector)
}

#Authorization: {
	#SafeAuthorization

	// File to read a secret from, mutually exclusive with `credentials`.
	credentialsFile?: string @go(CredentialsFile)
}
