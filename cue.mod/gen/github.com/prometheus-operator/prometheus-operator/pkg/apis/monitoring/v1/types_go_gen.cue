// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1

package v1

import (
	"k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/apimachinery/pkg/api/resource"
)

#Version: "v1"

// ByteSize is a valid memory size type based on powers-of-2, so 1KB is 1024B.
// Supported units: B, KB, KiB, MB, MiB, GB, GiB, TB, TiB, PB, PiB, EB, EiB Ex: `512MB`.
// +kubebuilder:validation:Pattern:="(^0|([0-9]*[.])?[0-9]+((K|M|G|T|E|P)i?)?B)$"
#ByteSize: string

// Duration is a valid time duration that can be parsed by Prometheus model.ParseDuration() function.
// Supported units: y, w, d, h, m, s, ms
// Examples: `30s`, `1m`, `1h20m15s`, `15d`
// +kubebuilder:validation:Pattern:="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
#Duration: string

// NonEmptyDuration is a valid time duration that can be parsed by Prometheus model.ParseDuration() function.
// Compared to Duration,  NonEmptyDuration enforces a minimum length of 1.
// Supported units: y, w, d, h, m, s, ms
// Examples: `30s`, `1m`, `1h20m15s`, `15d`
// +kubebuilder:validation:Pattern:="^(0|(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
// +kubebuilder:validation:MinLength=1
#NonEmptyDuration: string

// GoDuration is a valid time duration that can be parsed by Go's time.ParseDuration() function.
// Supported units: h, m, s, ms
// Examples: `45ms`, `30s`, `1m`, `1h20m15s`
// +kubebuilder:validation:Pattern:="^(0|(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?)$"
#GoDuration: string

// HostAlias holds the mapping between IP and hostnames that will be injected as an entry in the
// pod's hosts file.
#HostAlias: {
	// ip defines the IP address of the host file entry.
	// +required
	ip: string @go(IP)

	// hostnames defines hostnames for the above IP address.
	// +required
	hostnames: [...string] @go(Hostnames,[]string)
}

// PrometheusRuleExcludeConfig enables users to configure excluded
// PrometheusRule names and their namespaces to be ignored while enforcing
// namespace label for alerts and metrics.
#PrometheusRuleExcludeConfig: {
	// ruleNamespace defines the namespace of the excluded PrometheusRule object.
	// +required
	ruleNamespace: string @go(RuleNamespace)

	// ruleName defines the name of the excluded PrometheusRule object.
	// +required
	ruleName: string @go(RuleName)
}

#ProxyConfig: {
	// proxyUrl defines the HTTP proxy server to use.
	//
	// +kubebuilder:validation:Pattern:="^(http|https|socks5)://.+$"
	// +optional
	proxyUrl?: null | string @go(ProxyURL,*string)

	// noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names
	// that should be excluded from proxying. IP and domain names can
	// contain port numbers.
	//
	// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
	// +optional
	noProxy?: null | string @go(NoProxy,*string)

	// proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).
	//
	// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
	// +optional
	proxyFromEnvironment?: null | bool @go(ProxyFromEnvironment,*bool)

	// proxyConnectHeader optionally specifies headers to send to
	// proxies during CONNECT requests.
	//
	// It requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0.
	// +optional
	// +mapType:=atomic
	proxyConnectHeader?: {[string]: [...v1.#SecretKeySelector]} @go(ProxyConnectHeader,map[string][]v1.SecretKeySelector)
}

// ObjectReference references a PodMonitor, ServiceMonitor, Probe or PrometheusRule object.
#ObjectReference: {
	// group of the referent. When not specified, it defaults to `monitoring.coreos.com`
	// +optional
	// +kubebuilder:default:="monitoring.coreos.com"
	// +kubebuilder:validation:Enum=monitoring.coreos.com
	group?: string @go(Group)

	// resource of the referent.
	// +required
	// +kubebuilder:validation:Enum=prometheusrules;servicemonitors;podmonitors;probes;scrapeconfigs
	resource: string @go(Resource)

	// namespace of the referent.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
	// +required
	// +kubebuilder:validation:MinLength=1
	namespace: string @go(Namespace)

	// name of the referent. When not set, all resources in the namespace are matched.
	// +optional
	name?: string @go(Name)
}

// ArbitraryFSAccessThroughSMsConfig enables users to configure, whether
// a service monitor selected by the Prometheus instance is allowed to use
// arbitrary files on the file system of the Prometheus container. This is the case
// when e.g. a service monitor specifies a BearerTokenFile in an endpoint. A
// malicious user could create a service monitor selecting arbitrary secret files
// in the Prometheus container. Those secrets would then be sent with a scrape
// request by Prometheus to a malicious target. Denying the above would prevent the
// attack, users can instead use the BearerTokenSecret field.
#ArbitraryFSAccessThroughSMsConfig: {
	// deny prevents service monitors from accessing arbitrary files on the file system.
	// When true, service monitors cannot use file-based configurations like BearerTokenFile
	// that could potentially access sensitive files. When false (default), such access is allowed.
	// Setting this to true enhances security by preventing potential credential theft attacks.
	//
	// +optional
	deny?: bool @go(Deny)
}

// Condition represents the state of the resources associated with the
// Prometheus, Alertmanager or ThanosRuler resource.
// +k8s:deepcopy-gen=true
#Condition: {
	// type of the condition being reported.
	// +required
	type: #ConditionType @go(Type)

	// status of the condition.
	// +required
	status: #ConditionStatus @go(Status)

	// lastTransitionTime is the time of the last update to the current status property.
	// +required
	lastTransitionTime: metav1.#Time @go(LastTransitionTime)

	// reason for the condition's last transition.
	// +optional
	reason?: string @go(Reason)

	// message defines human-readable message indicating details for the condition's last transition.
	// +optional
	message?: string @go(Message)

	// observedGeneration defines the .metadata.generation that the
	// condition was set based upon. For instance, if `.metadata.generation` is
	// currently 12, but the `.status.conditions[].observedGeneration` is 9, the
	// condition is out of date with respect to the current state of the
	// instance.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)
}

// +kubebuilder:validation:MinLength=1
#ConditionType: string // #enumConditionType

#enumConditionType:
	#Available |
	#Reconciled |
	#Accepted

// Available indicates whether enough pods are ready to provide the
// service.
// The possible status values for this condition type are:
// - True: all pods are running and ready, the service is fully available.
// - Degraded: some pods aren't ready, the service is partially available.
// - False: no pods are running, the service is totally unavailable.
// - Unknown: the operator couldn't determine the condition status.
#Available: #ConditionType & "Available"

// Reconciled indicates whether the operator has reconciled the state of
// the underlying resources with the object's spec.
// The possible status values for this condition type are:
// - True: the reconciliation was successful.
// - False: the reconciliation failed.
// - Unknown: the operator couldn't determine the condition status.
#Reconciled: #ConditionType & "Reconciled"

// Accepted indicates whether the workload controller has successfully accepted
// the configuration resource and updated the configuration of the workload accordingly.
// The possible status values for this condition type are:
// - True: the configuration resource was successfully accepted by the controller and written to the configuration secret.
// - False: the controller rejected the configuration due to an error.
// - Unknown: the operator couldn't determine the condition status.
#Accepted: #ConditionType & "Accepted"

// +kubebuilder:validation:MinLength=1
#ConditionStatus: string // #enumConditionStatus

#enumConditionStatus:
	#ConditionTrue |
	#ConditionDegraded |
	#ConditionFalse |
	#ConditionUnknown

#ConditionTrue:     #ConditionStatus & "True"
#ConditionDegraded: #ConditionStatus & "Degraded"
#ConditionFalse:    #ConditionStatus & "False"
#ConditionUnknown:  #ConditionStatus & "Unknown"

// EmbeddedPersistentVolumeClaim is an embedded version of k8s.io/api/core/v1.PersistentVolumeClaim.
// It contains TypeMeta and a reduced ObjectMeta.
#EmbeddedPersistentVolumeClaim: {
	metav1.#TypeMeta

	// metadata defines EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
	// +optional
	metadata?: #EmbeddedObjectMetadata @go(EmbeddedObjectMetadata) @protobuf(1,bytes,opt)

	// spec defines the specification of the  characteristics of a volume requested by a pod author.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +optional
	spec?: v1.#PersistentVolumeClaimSpec @go(Spec) @protobuf(2,bytes,opt)

	// status is deprecated: this field is never set.
	// +optional
	status?: v1.#PersistentVolumeClaimStatus @go(Status) @protobuf(3,bytes,opt)
}

// EmbeddedObjectMetadata contains a subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta
// Only fields which are relevant to embedded resources are included.
#EmbeddedObjectMetadata: {
	// name must be unique within a namespace. Is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	// Cannot be updated.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/
	// +optional
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// labels define the map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string) @protobuf(11,bytes,rep)

	// annotations defines an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string) @protobuf(12,bytes,rep)
}

// WebConfigFileFields defines the file content for --web.config.file flag.
// +k8s:deepcopy-gen=true
#WebConfigFileFields: {
	// tlsConfig defines the TLS parameters for HTTPS.
	// +optional
	tlsConfig?: null | #WebTLSConfig @go(TLSConfig,*WebTLSConfig)

	// httpConfig defines HTTP parameters for web server.
	// +optional
	httpConfig?: null | #WebHTTPConfig @go(HTTPConfig,*WebHTTPConfig)
}

// WebHTTPConfig defines HTTP parameters for web server.
// +k8s:openapi-gen=true
#WebHTTPConfig: {
	// http2 enable HTTP/2 support. Note that HTTP/2 is only supported with TLS.
	// When TLSConfig is not configured, HTTP/2 will be disabled.
	// Whenever the value of the field changes, a rolling update will be triggered.
	// +optional
	http2?: null | bool @go(HTTP2,*bool)

	// headers defines a list of headers that can be added to HTTP responses.
	// +optional
	headers?: null | #WebHTTPHeaders @go(Headers,*WebHTTPHeaders)
}

// WebHTTPHeaders defines the list of headers that can be added to HTTP responses.
// +k8s:openapi-gen=true
#WebHTTPHeaders: {
	// contentSecurityPolicy defines the Content-Security-Policy header to HTTP responses.
	// Unset if blank.
	// +optional
	contentSecurityPolicy?: string @go(ContentSecurityPolicy)

	// xFrameOptions defines the X-Frame-Options header to HTTP responses.
	// Unset if blank. Accepted values are deny and sameorigin.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
	// +kubebuilder:validation:Enum="";Deny;SameOrigin
	// +optional
	xFrameOptions?: string @go(XFrameOptions)

	// xContentTypeOptions defines the X-Content-Type-Options header to HTTP responses.
	// Unset if blank. Accepted value is nosniff.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
	// +kubebuilder:validation:Enum="";NoSniff
	// +optional
	xContentTypeOptions?: string @go(XContentTypeOptions)

	// xXSSProtection defines the X-XSS-Protection header to all responses.
	// Unset if blank.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
	// +optional
	xXSSProtection?: string @go(XXSSProtection)

	// strictTransportSecurity defines the Strict-Transport-Security header to HTTP responses.
	// Unset if blank.
	// Please make sure that you use this with care as this header might force
	// browsers to load Prometheus and the other applications hosted on the same
	// domain and subdomains over HTTPS.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
	// +optional
	strictTransportSecurity?: string @go(StrictTransportSecurity)
}

// WebTLSConfig defines the TLS parameters for HTTPS.
// +k8s:openapi-gen=true
#WebTLSConfig: {
	// cert defines the Secret or ConfigMap containing the TLS certificate for the web server.
	//
	// Either `keySecret` or `keyFile` must be defined.
	//
	// It is mutually exclusive with `certFile`.
	//
	// +optional
	cert?: #SecretOrConfigMap @go(Cert)

	// certFile defines the path to the TLS certificate file in the container for the web server.
	//
	// Either `keySecret` or `keyFile` must be defined.
	//
	// It is mutually exclusive with `cert`.
	//
	// +optional
	certFile?: null | string @go(CertFile,*string)

	// keySecret defines the secret containing the TLS private key for the web server.
	//
	// Either `cert` or `certFile` must be defined.
	//
	// It is mutually exclusive with `keyFile`.
	//
	// +optional
	keySecret?: v1.#SecretKeySelector @go(KeySecret)

	// keyFile defines the path to the TLS private key file in the container for the web server.
	//
	// If defined, either `cert` or `certFile` must be defined.
	//
	// It is mutually exclusive with `keySecret`.
	//
	// +optional
	keyFile?: null | string @go(KeyFile,*string)

	// client_ca defines the Secret or ConfigMap containing the CA certificate for client certificate
	// authentication to the server.
	//
	// It is mutually exclusive with `clientCAFile`.
	//
	// +optional
	//nolint:kubeapilinter // The json tag doesn't meet the conventions to be compatible with Prometheus format.
	client_ca?: #SecretOrConfigMap @go(ClientCA)

	// clientCAFile defines the path to the CA certificate file for client certificate authentication to
	// the server.
	//
	// It is mutually exclusive with `client_ca`.
	//
	// +optional
	clientCAFile?: null | string @go(ClientCAFile,*string)

	// clientAuthType defines the server policy for client TLS authentication.
	//
	// For more detail on clientAuth options:
	// https://golang.org/pkg/crypto/tls/#ClientAuthType
	//
	// +optional
	clientAuthType?: null | string @go(ClientAuthType,*string)

	// minVersion defines the minimum TLS version that is acceptable.
	//
	// +optional
	minVersion?: null | string @go(MinVersion,*string)

	// maxVersion defines the Maximum TLS version that is acceptable.
	//
	// +optional
	maxVersion?: null | string @go(MaxVersion,*string)

	// cipherSuites defines the list of supported cipher suites for TLS versions up to TLS 1.2.
	//
	// If not defined, the Go default cipher suites are used.
	// Available cipher suites are documented in the Go documentation:
	// https://golang.org/pkg/crypto/tls/#pkg-constants
	//
	// +optional
	cipherSuites?: [...string] @go(CipherSuites,[]string)

	// preferServerCipherSuites defines whether the server selects the client's most preferred cipher
	// suite, or the server's most preferred cipher suite.
	//
	// If true then the server's preference, as expressed in
	// the order of elements in cipherSuites, is used.
	//
	// +optional
	preferServerCipherSuites?: null | bool @go(PreferServerCipherSuites,*bool)

	// curvePreferences defines elliptic curves that will be used in an ECDHE handshake, in preference
	// order.
	//
	// Available curves are documented in the Go documentation:
	// https://golang.org/pkg/crypto/tls/#CurveID
	//
	// +optional
	curvePreferences?: [...string] @go(CurvePreferences,[]string)
}

// LabelName is a valid Prometheus label name.
// For Prometheus 3.x, a label name is valid if it contains UTF-8 characters.
// For Prometheus 2.x, a label name is only valid if it contains ASCII characters, letters, numbers, as well as underscores.
#LabelName: string

// Endpoint defines an endpoint serving Prometheus metrics to be scraped by
// Prometheus.
//
// +k8s:openapi-gen=true
#Endpoint: {
	// port defines the name of the Service port which this endpoint refers to.
	//
	// It takes precedence over `targetPort`.
	// +optional
	port?: string @go(Port)

	// targetPort defines the name or number of the target port of the `Pod` object behind the
	// Service. The port must be specified with the container's port property.
	//
	// +optional
	targetPort?: null | intstr.#IntOrString @go(TargetPort,*intstr.IntOrString)

	// path defines the HTTP path from which to scrape for metrics.
	//
	// If empty, Prometheus uses the default value (e.g. `/metrics`).
	// +optional
	path?: string @go(Path)

	// scheme defines the HTTP scheme to use for scraping.
	//
	// `http` and `https` are the expected values unless you rewrite the
	// `__scheme__` label via relabeling.
	//
	// If empty, Prometheus uses the default value `http`.
	//
	// +kubebuilder:validation:Enum=http;https
	// +optional
	scheme?: string @go(Scheme)

	// params define optional HTTP URL parameters.
	// +optional
	params?: {[string]: [...string]} @go(Params,map[string][]string)

	// interval at which Prometheus scrapes the metrics from the target.
	//
	// If empty, Prometheus uses the global scrape interval.
	// +optional
	interval?: #Duration @go(Interval)

	// scrapeTimeout defines the timeout after which Prometheus considers the scrape to be failed.
	//
	// If empty, Prometheus uses the global scrape timeout unless it is less
	// than the target's scrape interval value in which the latter is used.
	// The value cannot be greater than the scrape interval otherwise the operator will reject the resource.
	// +optional
	scrapeTimeout?: #Duration @go(ScrapeTimeout)

	// tlsConfig defines the TLS configuration to use when scraping the target.
	//
	// +optional
	tlsConfig?: null | #TLSConfig @go(TLSConfig,*TLSConfig)

	// bearerTokenFile defines the file to read bearer token for scraping the target.
	//
	// Deprecated: use `authorization` instead.
	// +optional
	bearerTokenFile?: string @go(BearerTokenFile)

	// bearerTokenSecret defines a key of a Secret containing the bearer
	// token for scraping targets. The secret needs to be in the same namespace
	// as the ServiceMonitor object and readable by the Prometheus Operator.
	//
	// +optional
	//
	// Deprecated: use `authorization` instead.
	bearerTokenSecret?: null | v1.#SecretKeySelector @go(BearerTokenSecret,*v1.SecretKeySelector)

	// authorization configures the Authorization header credentials to use when
	// scraping the target.
	//
	// Cannot be set at the same time as `basicAuth`, or `oauth2`.
	//
	// +optional
	authorization?: null | #SafeAuthorization @go(Authorization,*SafeAuthorization)

	// honorLabels defines when true the metric's labels when they collide
	// with the target's labels.
	// +optional
	honorLabels?: bool @go(HonorLabels)

	// honorTimestamps defines whether Prometheus preserves the timestamps
	// when exposed by the target.
	//
	// +optional
	honorTimestamps?: null | bool @go(HonorTimestamps,*bool)

	// trackTimestampsStaleness defines whether Prometheus tracks staleness of
	// the metrics that have an explicit timestamp present in scraped data.
	// Has no effect if `honorTimestamps` is false.
	//
	// It requires Prometheus >= v2.48.0.
	//
	// +optional
	trackTimestampsStaleness?: null | bool @go(TrackTimestampsStaleness,*bool)

	// basicAuth defines the Basic Authentication credentials to use when
	// scraping the target.
	//
	// Cannot be set at the same time as `authorization`, or `oauth2`.
	//
	// +optional
	basicAuth?: null | #BasicAuth @go(BasicAuth,*BasicAuth)

	// oauth2 defines the OAuth2 settings to use when scraping the target.
	//
	// It requires Prometheus >= 2.27.0.
	//
	// Cannot be set at the same time as `authorization`, or `basicAuth`.
	//
	// +optional
	oauth2?: null | #OAuth2 @go(OAuth2,*OAuth2)

	// metricRelabelings defines the relabeling rules to apply to the
	// samples before ingestion.
	//
	// +optional
	metricRelabelings?: [...#RelabelConfig] @go(MetricRelabelConfigs,[]RelabelConfig)

	// relabelings defines the relabeling rules to apply the target's
	// metadata labels.
	//
	// The Operator automatically adds relabelings for a few standard Kubernetes fields.
	//
	// The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
	//
	// More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
	//
	// +optional
	relabelings?: [...#RelabelConfig] @go(RelabelConfigs,[]RelabelConfig)

	#ProxyConfig

	// followRedirects defines whether the scrape requests should follow HTTP
	// 3xx redirects.
	//
	// +optional
	followRedirects?: null | bool @go(FollowRedirects,*bool)

	// enableHttp2 can be used to disable HTTP2 when scraping the target.
	//
	// +optional
	enableHttp2?: null | bool @go(EnableHttp2,*bool)

	// filterRunning when true, the pods which are not running (e.g. either in Failed or
	// Succeeded state) are dropped during the target discovery.
	//
	// If unset, the filtering is enabled.
	//
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase
	//
	// +optional
	filterRunning?: null | bool @go(FilterRunning,*bool)
}

#AttachMetadata: {
	// node when set to true, Prometheus attaches node metadata to the discovered
	// targets.
	//
	// The Prometheus service account must have the `list` and `watch`
	// permissions on the `Nodes` objects.
	//
	// +optional
	node?: null | bool @go(Node,*bool)
}

// OAuth2 configures OAuth2 settings.
//
// +k8s:openapi-gen=true
#OAuth2: {
	// clientId defines a key of a Secret or ConfigMap containing the
	// OAuth2 client's ID.
	// +required
	clientId: #SecretOrConfigMap @go(ClientID)

	// clientSecret defines a key of a Secret containing the OAuth2
	// client's secret.
	// +required
	clientSecret: v1.#SecretKeySelector @go(ClientSecret)

	// tokenUrl defines the URL to fetch the token from.
	//
	// +kubebuilder:validation:MinLength=1
	// +required
	tokenUrl: string @go(TokenURL)

	// scopes defines the OAuth2 scopes used for the token request.
	//
	// +optional.
	scopes?: [...string] @go(Scopes,[]string)

	// endpointParams configures the HTTP parameters to append to the token
	// URL.
	//
	// +optional
	endpointParams?: {[string]: string} @go(EndpointParams,map[string]string)

	// tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.
	// It requires Prometheus >= v2.43.0.
	//
	// +optional
	tlsConfig?: null | #SafeTLSConfig @go(TLSConfig,*SafeTLSConfig)

	#ProxyConfig
}

// BasicAuth configures HTTP Basic Authentication settings.
//
// +k8s:openapi-gen=true
#BasicAuth: {
	// username defines a key of a Secret containing the username for
	// authentication.
	// +optional
	username?: v1.#SecretKeySelector @go(Username)

	// password defines a key of a Secret containing the password for
	// authentication.
	// +optional
	password?: v1.#SecretKeySelector @go(Password)
}

// SecretOrConfigMap allows to specify data as a Secret or ConfigMap. Fields are mutually exclusive.
#SecretOrConfigMap: {
	// secret defines the Secret containing data to use for the targets.
	// +optional
	secret?: null | v1.#SecretKeySelector @go(Secret,*v1.SecretKeySelector)

	// configMap defines the ConfigMap containing data to use for the targets.
	// +optional
	configMap?: null | v1.#ConfigMapKeySelector @go(ConfigMap,*v1.ConfigMapKeySelector)
}

// +kubebuilder:validation:Enum=TLS10;TLS11;TLS12;TLS13
#TLSVersion: string // #enumTLSVersion

#enumTLSVersion:
	#TLSVersion10 |
	#TLSVersion11 |
	#TLSVersion12 |
	#TLSVersion13

#TLSVersion10: #TLSVersion & "TLS10"
#TLSVersion11: #TLSVersion & "TLS11"
#TLSVersion12: #TLSVersion & "TLS12"
#TLSVersion13: #TLSVersion & "TLS13"

// SafeTLSConfig specifies safe TLS configuration parameters.
// +k8s:openapi-gen=true
#SafeTLSConfig: {
	// ca defines the Certificate authority used when verifying server certificates.
	// +optional
	ca?: #SecretOrConfigMap @go(CA)

	// cert defines the Client certificate to present when doing client-authentication.
	// +optional
	cert?: #SecretOrConfigMap @go(Cert)

	// keySecret defines the Secret containing the client key file for the targets.
	// +optional
	keySecret?: null | v1.#SecretKeySelector @go(KeySecret,*v1.SecretKeySelector)

	// serverName is used to verify the hostname for the targets.
	// +optional
	serverName?: null | string @go(ServerName,*string)

	// insecureSkipVerify defines how to disable target certificate validation.
	// +optional
	insecureSkipVerify?: null | bool @go(InsecureSkipVerify,*bool)

	// minVersion defines the minimum acceptable TLS version.
	//
	// It requires Prometheus >= v2.35.0 or Thanos >= v0.28.0.
	// +optional
	minVersion?: null | #TLSVersion @go(MinVersion,*TLSVersion)

	// maxVersion defines the maximum acceptable TLS version.
	//
	// It requires Prometheus >= v2.41.0 or Thanos >= v0.31.0.
	// +optional
	maxVersion?: null | #TLSVersion @go(MaxVersion,*TLSVersion)
}

// TLSConfig extends the safe TLS configuration with file parameters.
// +k8s:openapi-gen=true
#TLSConfig: {
	#SafeTLSConfig

	// caFile defines the path to the CA cert in the Prometheus container to use for the targets.
	// +optional
	caFile?: string @go(CAFile)

	// certFile defines the path to the client cert file in the Prometheus container for the targets.
	// +optional
	certFile?: string @go(CertFile)

	// keyFile defines the path to the client key file in the Prometheus container for the targets.
	// +optional
	keyFile?: string @go(KeyFile)
}

// NamespaceSelector is a selector for selecting either all namespaces or a
// list of namespaces.
// If `any` is true, it takes precedence over `matchNames`.
// If `matchNames` is empty and `any` is false, it means that the objects are
// selected from the current namespace.
// +k8s:openapi-gen=true
#NamespaceSelector: {
	// any defines the boolean describing whether all namespaces are selected in contrast to a
	// list restricting them.
	// +optional
	any?: bool @go(Any)

	// matchNames defines the list of namespace names to select from.
	// +optional
	matchNames?: [...string] @go(MatchNames,[]string)
}

// Argument as part of the AdditionalArgs list.
// +k8s:openapi-gen=true
#Argument: {
	// name of the argument, e.g. "scrape.discovery-reload-interval".
	// +kubebuilder:validation:MinLength=1
	// +required
	name: string @go(Name)

	// value defines the argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
	// +optional
	value?: string @go(Value)
}

#RoleNode:          "node"
#RolePod:           "pod"
#RoleService:       "service"
#RoleEndpoint:      "endpoints"
#RoleEndpointSlice: "endpointslice"
#RoleIngress:       "ingress"

// NativeHistogramConfig extends the native histogram configuration settings.
// +k8s:openapi-gen=true
#NativeHistogramConfig: {
	// scrapeClassicHistograms defines whether to scrape a classic histogram that is also exposed as a native histogram.
	// It requires Prometheus >= v2.45.0.
	//
	// Notice: `scrapeClassicHistograms` corresponds to the `always_scrape_classic_histograms` field in the Prometheus configuration.
	//
	// +optional
	scrapeClassicHistograms?: null | bool @go(ScrapeClassicHistograms,*bool)

	// nativeHistogramBucketLimit defines ff there are more than this many buckets in a native histogram,
	// buckets will be merged to stay within the limit.
	// It requires Prometheus >= v2.45.0.
	//
	// +optional
	nativeHistogramBucketLimit?: null | uint64 @go(NativeHistogramBucketLimit,*uint64)

	// nativeHistogramMinBucketFactor defines if the growth factor of one bucket to the next is smaller than this,
	// buckets will be merged to increase the factor sufficiently.
	// It requires Prometheus >= v2.50.0.
	//
	// +optional
	nativeHistogramMinBucketFactor?: null | resource.#Quantity @go(NativeHistogramMinBucketFactor,*resource.Quantity)

	// convertClassicHistogramsToNHCB defines whether to convert all scraped classic histograms into a native histogram with custom buckets.
	// It requires Prometheus >= v3.0.0.
	//
	// +optional
	convertClassicHistogramsToNHCB?: null | bool @go(ConvertClassicHistogramsToNHCB,*bool)
}

// +kubebuilder:validation:Enum=RelabelConfig;RoleSelector
#SelectorMechanism: string // #enumSelectorMechanism

#enumSelectorMechanism:
	#SelectorMechanismRelabel |
	#SelectorMechanismRole

#SelectorMechanismRelabel: #SelectorMechanism & "RelabelConfig"
#SelectorMechanismRole:    #SelectorMechanism & "RoleSelector"

// ConfigResourceStatus is the most recent observed status of the Configuration Resource (ServiceMonitor, PodMonitor, Probes, ScrapeConfig, PrometheusRule or AlertmanagerConfig). Read-only.
// More info:
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
// +k8s:openapi-gen=true
#ConfigResourceStatus: {
	// bindings defines the list of workload resources (Prometheus, PrometheusAgent, ThanosRuler or Alertmanager) which select the configuration resource.
	// +listType=map
	// +listMapKey=group
	// +listMapKey=resource
	// +listMapKey=name
	// +listMapKey=namespace
	// +optional
	bindings?: [...#WorkloadBinding] @go(Bindings,[]WorkloadBinding)
}

// WorkloadBinding is a link between a configuration resource and a workload resource.
// +k8s:openapi-gen=true
#WorkloadBinding: {
	// group defines the group of the referenced resource.
	// +kubebuilder:validation:Enum=monitoring.coreos.com
	// +required
	group: string @go(Group)

	// resource defines the type of resource being referenced (e.g. Prometheus, PrometheusAgent, ThanosRuler or Alertmanager).
	// +kubebuilder:validation:Enum=prometheuses;prometheusagents;thanosrulers;alertmanagers
	// +required
	resource: string @go(Resource)

	// name defines the name of the referenced object.
	// +kubebuilder:validation:MinLength=1
	// +required
	name: string @go(Name)

	// namespace defines the namespace of the referenced object.
	// +kubebuilder:validation:MinLength=1
	// +required
	namespace: string @go(Namespace)

	// conditions defines the current state of the configuration resource when bound to the referenced Workload object.
	// +listType=map
	// +listMapKey=type
	// +optional
	conditions?: [...#ConfigResourceCondition] @go(Conditions,[]ConfigResourceCondition)
}

// ConfigResourceCondition describes the status of configuration resources linked to Prometheus, PrometheusAgent, Alertmanager or ThanosRuler.
// +k8s:deepcopy-gen=true
#ConfigResourceCondition: {
	// type of the condition being reported.
	// Currently, only "Accepted" is supported.
	// +kubebuilder:validation:Enum=Accepted
	// +required
	type: #ConditionType @go(Type)

	// status of the condition.
	// +required
	status: #ConditionStatus @go(Status)

	// lastTransitionTime defines the time of the last update to the current status property.
	// +required
	lastTransitionTime: metav1.#Time @go(LastTransitionTime)

	// reason for the condition's last transition.
	// +optional
	reason?: string @go(Reason)

	// message defines the human-readable message indicating details for the condition's last transition.
	// +optional
	message?: string @go(Message)

	// observedGeneration defines the .metadata.generation that the
	// condition was set based upon. For instance, if `.metadata.generation` is
	// currently 12, but the `.status.conditions[].observedGeneration` is 9, the
	// condition is out of date with respect to the current state of the object.
	// +optional
	observedGeneration?: int64 @go(ObservedGeneration)
}
