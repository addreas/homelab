// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go net/http

package http

import (
	"vendor/golang.org/x/net/http2/hpack"
	"time"
	"context"
	"crypto/tls"
)

_#http2cipher_TLS_NULL_WITH_NULL_NULL:               uint16 & 0x0000
_#http2cipher_TLS_RSA_WITH_NULL_MD5:                 uint16 & 0x0001
_#http2cipher_TLS_RSA_WITH_NULL_SHA:                 uint16 & 0x0002
_#http2cipher_TLS_RSA_EXPORT_WITH_RC4_40_MD5:        uint16 & 0x0003
_#http2cipher_TLS_RSA_WITH_RC4_128_MD5:              uint16 & 0x0004
_#http2cipher_TLS_RSA_WITH_RC4_128_SHA:              uint16 & 0x0005
_#http2cipher_TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5:    uint16 & 0x0006
_#http2cipher_TLS_RSA_WITH_IDEA_CBC_SHA:             uint16 & 0x0007
_#http2cipher_TLS_RSA_EXPORT_WITH_DES40_CBC_SHA:     uint16 & 0x0008
_#http2cipher_TLS_RSA_WITH_DES_CBC_SHA:              uint16 & 0x0009
_#http2cipher_TLS_RSA_WITH_3DES_EDE_CBC_SHA:         uint16 & 0x000A
_#http2cipher_TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA:  uint16 & 0x000B
_#http2cipher_TLS_DH_DSS_WITH_DES_CBC_SHA:           uint16 & 0x000C
_#http2cipher_TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA:      uint16 & 0x000D
_#http2cipher_TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA:  uint16 & 0x000E
_#http2cipher_TLS_DH_RSA_WITH_DES_CBC_SHA:           uint16 & 0x000F
_#http2cipher_TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA:      uint16 & 0x0010
_#http2cipher_TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA: uint16 & 0x0011
_#http2cipher_TLS_DHE_DSS_WITH_DES_CBC_SHA:          uint16 & 0x0012
_#http2cipher_TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA:     uint16 & 0x0013
_#http2cipher_TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA: uint16 & 0x0014
_#http2cipher_TLS_DHE_RSA_WITH_DES_CBC_SHA:          uint16 & 0x0015
_#http2cipher_TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA:     uint16 & 0x0016
_#http2cipher_TLS_DH_anon_EXPORT_WITH_RC4_40_MD5:    uint16 & 0x0017
_#http2cipher_TLS_DH_anon_WITH_RC4_128_MD5:          uint16 & 0x0018
_#http2cipher_TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA: uint16 & 0x0019
_#http2cipher_TLS_DH_anon_WITH_DES_CBC_SHA:          uint16 & 0x001A
_#http2cipher_TLS_DH_anon_WITH_3DES_EDE_CBC_SHA:     uint16 & 0x001B

// Reserved uint16 =  0x001C-1D
_#http2cipher_TLS_KRB5_WITH_DES_CBC_SHA:             uint16 & 0x001E
_#http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_SHA:        uint16 & 0x001F
_#http2cipher_TLS_KRB5_WITH_RC4_128_SHA:             uint16 & 0x0020
_#http2cipher_TLS_KRB5_WITH_IDEA_CBC_SHA:            uint16 & 0x0021
_#http2cipher_TLS_KRB5_WITH_DES_CBC_MD5:             uint16 & 0x0022
_#http2cipher_TLS_KRB5_WITH_3DES_EDE_CBC_MD5:        uint16 & 0x0023
_#http2cipher_TLS_KRB5_WITH_RC4_128_MD5:             uint16 & 0x0024
_#http2cipher_TLS_KRB5_WITH_IDEA_CBC_MD5:            uint16 & 0x0025
_#http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA:   uint16 & 0x0026
_#http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA:   uint16 & 0x0027
_#http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_SHA:       uint16 & 0x0028
_#http2cipher_TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5:   uint16 & 0x0029
_#http2cipher_TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5:   uint16 & 0x002A
_#http2cipher_TLS_KRB5_EXPORT_WITH_RC4_40_MD5:       uint16 & 0x002B
_#http2cipher_TLS_PSK_WITH_NULL_SHA:                 uint16 & 0x002C
_#http2cipher_TLS_DHE_PSK_WITH_NULL_SHA:             uint16 & 0x002D
_#http2cipher_TLS_RSA_PSK_WITH_NULL_SHA:             uint16 & 0x002E
_#http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA:          uint16 & 0x002F
_#http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA:       uint16 & 0x0030
_#http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA:       uint16 & 0x0031
_#http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA:      uint16 & 0x0032
_#http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA:      uint16 & 0x0033
_#http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA:      uint16 & 0x0034
_#http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA:          uint16 & 0x0035
_#http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA:       uint16 & 0x0036
_#http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA:       uint16 & 0x0037
_#http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA:      uint16 & 0x0038
_#http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA:      uint16 & 0x0039
_#http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA:      uint16 & 0x003A
_#http2cipher_TLS_RSA_WITH_NULL_SHA256:              uint16 & 0x003B
_#http2cipher_TLS_RSA_WITH_AES_128_CBC_SHA256:       uint16 & 0x003C
_#http2cipher_TLS_RSA_WITH_AES_256_CBC_SHA256:       uint16 & 0x003D
_#http2cipher_TLS_DH_DSS_WITH_AES_128_CBC_SHA256:    uint16 & 0x003E
_#http2cipher_TLS_DH_RSA_WITH_AES_128_CBC_SHA256:    uint16 & 0x003F
_#http2cipher_TLS_DHE_DSS_WITH_AES_128_CBC_SHA256:   uint16 & 0x0040
_#http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA:     uint16 & 0x0041
_#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA:  uint16 & 0x0042
_#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA:  uint16 & 0x0043
_#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: uint16 & 0x0044
_#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: uint16 & 0x0045
_#http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA: uint16 & 0x0046

// Reserved uint16 =  0x0047-4F
// Reserved uint16 =  0x0050-58
// Reserved uint16 =  0x0059-5C
// Unassigned uint16 =  0x005D-5F
// Reserved uint16 =  0x0060-66
_#http2cipher_TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: uint16 & 0x0067
_#http2cipher_TLS_DH_DSS_WITH_AES_256_CBC_SHA256:  uint16 & 0x0068
_#http2cipher_TLS_DH_RSA_WITH_AES_256_CBC_SHA256:  uint16 & 0x0069
_#http2cipher_TLS_DHE_DSS_WITH_AES_256_CBC_SHA256: uint16 & 0x006A
_#http2cipher_TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: uint16 & 0x006B
_#http2cipher_TLS_DH_anon_WITH_AES_128_CBC_SHA256: uint16 & 0x006C
_#http2cipher_TLS_DH_anon_WITH_AES_256_CBC_SHA256: uint16 & 0x006D

// Unassigned uint16 =  0x006E-83
_#http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA:        uint16 & 0x0084
_#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA:     uint16 & 0x0085
_#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA:     uint16 & 0x0086
_#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA:    uint16 & 0x0087
_#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA:    uint16 & 0x0088
_#http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA:    uint16 & 0x0089
_#http2cipher_TLS_PSK_WITH_RC4_128_SHA:                 uint16 & 0x008A
_#http2cipher_TLS_PSK_WITH_3DES_EDE_CBC_SHA:            uint16 & 0x008B
_#http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA:             uint16 & 0x008C
_#http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA:             uint16 & 0x008D
_#http2cipher_TLS_DHE_PSK_WITH_RC4_128_SHA:             uint16 & 0x008E
_#http2cipher_TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA:        uint16 & 0x008F
_#http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA:         uint16 & 0x0090
_#http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA:         uint16 & 0x0091
_#http2cipher_TLS_RSA_PSK_WITH_RC4_128_SHA:             uint16 & 0x0092
_#http2cipher_TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA:        uint16 & 0x0093
_#http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA:         uint16 & 0x0094
_#http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA:         uint16 & 0x0095
_#http2cipher_TLS_RSA_WITH_SEED_CBC_SHA:                uint16 & 0x0096
_#http2cipher_TLS_DH_DSS_WITH_SEED_CBC_SHA:             uint16 & 0x0097
_#http2cipher_TLS_DH_RSA_WITH_SEED_CBC_SHA:             uint16 & 0x0098
_#http2cipher_TLS_DHE_DSS_WITH_SEED_CBC_SHA:            uint16 & 0x0099
_#http2cipher_TLS_DHE_RSA_WITH_SEED_CBC_SHA:            uint16 & 0x009A
_#http2cipher_TLS_DH_anon_WITH_SEED_CBC_SHA:            uint16 & 0x009B
_#http2cipher_TLS_RSA_WITH_AES_128_GCM_SHA256:          uint16 & 0x009C
_#http2cipher_TLS_RSA_WITH_AES_256_GCM_SHA384:          uint16 & 0x009D
_#http2cipher_TLS_DHE_RSA_WITH_AES_128_GCM_SHA256:      uint16 & 0x009E
_#http2cipher_TLS_DHE_RSA_WITH_AES_256_GCM_SHA384:      uint16 & 0x009F
_#http2cipher_TLS_DH_RSA_WITH_AES_128_GCM_SHA256:       uint16 & 0x00A0
_#http2cipher_TLS_DH_RSA_WITH_AES_256_GCM_SHA384:       uint16 & 0x00A1
_#http2cipher_TLS_DHE_DSS_WITH_AES_128_GCM_SHA256:      uint16 & 0x00A2
_#http2cipher_TLS_DHE_DSS_WITH_AES_256_GCM_SHA384:      uint16 & 0x00A3
_#http2cipher_TLS_DH_DSS_WITH_AES_128_GCM_SHA256:       uint16 & 0x00A4
_#http2cipher_TLS_DH_DSS_WITH_AES_256_GCM_SHA384:       uint16 & 0x00A5
_#http2cipher_TLS_DH_anon_WITH_AES_128_GCM_SHA256:      uint16 & 0x00A6
_#http2cipher_TLS_DH_anon_WITH_AES_256_GCM_SHA384:      uint16 & 0x00A7
_#http2cipher_TLS_PSK_WITH_AES_128_GCM_SHA256:          uint16 & 0x00A8
_#http2cipher_TLS_PSK_WITH_AES_256_GCM_SHA384:          uint16 & 0x00A9
_#http2cipher_TLS_DHE_PSK_WITH_AES_128_GCM_SHA256:      uint16 & 0x00AA
_#http2cipher_TLS_DHE_PSK_WITH_AES_256_GCM_SHA384:      uint16 & 0x00AB
_#http2cipher_TLS_RSA_PSK_WITH_AES_128_GCM_SHA256:      uint16 & 0x00AC
_#http2cipher_TLS_RSA_PSK_WITH_AES_256_GCM_SHA384:      uint16 & 0x00AD
_#http2cipher_TLS_PSK_WITH_AES_128_CBC_SHA256:          uint16 & 0x00AE
_#http2cipher_TLS_PSK_WITH_AES_256_CBC_SHA384:          uint16 & 0x00AF
_#http2cipher_TLS_PSK_WITH_NULL_SHA256:                 uint16 & 0x00B0
_#http2cipher_TLS_PSK_WITH_NULL_SHA384:                 uint16 & 0x00B1
_#http2cipher_TLS_DHE_PSK_WITH_AES_128_CBC_SHA256:      uint16 & 0x00B2
_#http2cipher_TLS_DHE_PSK_WITH_AES_256_CBC_SHA384:      uint16 & 0x00B3
_#http2cipher_TLS_DHE_PSK_WITH_NULL_SHA256:             uint16 & 0x00B4
_#http2cipher_TLS_DHE_PSK_WITH_NULL_SHA384:             uint16 & 0x00B5
_#http2cipher_TLS_RSA_PSK_WITH_AES_128_CBC_SHA256:      uint16 & 0x00B6
_#http2cipher_TLS_RSA_PSK_WITH_AES_256_CBC_SHA384:      uint16 & 0x00B7
_#http2cipher_TLS_RSA_PSK_WITH_NULL_SHA256:             uint16 & 0x00B8
_#http2cipher_TLS_RSA_PSK_WITH_NULL_SHA384:             uint16 & 0x00B9
_#http2cipher_TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256:     uint16 & 0x00BA
_#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256:  uint16 & 0x00BB
_#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256:  uint16 & 0x00BC
_#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: uint16 & 0x00BD
_#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: uint16 & 0x00BE
_#http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256: uint16 & 0x00BF
_#http2cipher_TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256:     uint16 & 0x00C0
_#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256:  uint16 & 0x00C1
_#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256:  uint16 & 0x00C2
_#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: uint16 & 0x00C3
_#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: uint16 & 0x00C4
_#http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256: uint16 & 0x00C5

// Unassigned uint16 =  0x00C6-FE
_#http2cipher_TLS_EMPTY_RENEGOTIATION_INFO_SCSV: uint16 & 0x00FF

// Unassigned uint16 =  0x01-55,*
_#http2cipher_TLS_FALLBACK_SCSV: uint16 & 0x5600

// Unassigned                                   uint16 = 0x5601 - 0xC000
_#http2cipher_TLS_ECDH_ECDSA_WITH_NULL_SHA:                 uint16 & 0xC001
_#http2cipher_TLS_ECDH_ECDSA_WITH_RC4_128_SHA:              uint16 & 0xC002
_#http2cipher_TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA:         uint16 & 0xC003
_#http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA:          uint16 & 0xC004
_#http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA:          uint16 & 0xC005
_#http2cipher_TLS_ECDHE_ECDSA_WITH_NULL_SHA:                uint16 & 0xC006
_#http2cipher_TLS_ECDHE_ECDSA_WITH_RC4_128_SHA:             uint16 & 0xC007
_#http2cipher_TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA:        uint16 & 0xC008
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA:         uint16 & 0xC009
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA:         uint16 & 0xC00A
_#http2cipher_TLS_ECDH_RSA_WITH_NULL_SHA:                   uint16 & 0xC00B
_#http2cipher_TLS_ECDH_RSA_WITH_RC4_128_SHA:                uint16 & 0xC00C
_#http2cipher_TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA:           uint16 & 0xC00D
_#http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA:            uint16 & 0xC00E
_#http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA:            uint16 & 0xC00F
_#http2cipher_TLS_ECDHE_RSA_WITH_NULL_SHA:                  uint16 & 0xC010
_#http2cipher_TLS_ECDHE_RSA_WITH_RC4_128_SHA:               uint16 & 0xC011
_#http2cipher_TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA:          uint16 & 0xC012
_#http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA:           uint16 & 0xC013
_#http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA:           uint16 & 0xC014
_#http2cipher_TLS_ECDH_anon_WITH_NULL_SHA:                  uint16 & 0xC015
_#http2cipher_TLS_ECDH_anon_WITH_RC4_128_SHA:               uint16 & 0xC016
_#http2cipher_TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA:          uint16 & 0xC017
_#http2cipher_TLS_ECDH_anon_WITH_AES_128_CBC_SHA:           uint16 & 0xC018
_#http2cipher_TLS_ECDH_anon_WITH_AES_256_CBC_SHA:           uint16 & 0xC019
_#http2cipher_TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA:            uint16 & 0xC01A
_#http2cipher_TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA:        uint16 & 0xC01B
_#http2cipher_TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA:        uint16 & 0xC01C
_#http2cipher_TLS_SRP_SHA_WITH_AES_128_CBC_SHA:             uint16 & 0xC01D
_#http2cipher_TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA:         uint16 & 0xC01E
_#http2cipher_TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA:         uint16 & 0xC01F
_#http2cipher_TLS_SRP_SHA_WITH_AES_256_CBC_SHA:             uint16 & 0xC020
_#http2cipher_TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA:         uint16 & 0xC021
_#http2cipher_TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA:         uint16 & 0xC022
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256:      uint16 & 0xC023
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384:      uint16 & 0xC024
_#http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256:       uint16 & 0xC025
_#http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384:       uint16 & 0xC026
_#http2cipher_TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256:        uint16 & 0xC027
_#http2cipher_TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384:        uint16 & 0xC028
_#http2cipher_TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256:         uint16 & 0xC029
_#http2cipher_TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384:         uint16 & 0xC02A
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:      uint16 & 0xC02B
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384:      uint16 & 0xC02C
_#http2cipher_TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256:       uint16 & 0xC02D
_#http2cipher_TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384:       uint16 & 0xC02E
_#http2cipher_TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256:        uint16 & 0xC02F
_#http2cipher_TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384:        uint16 & 0xC030
_#http2cipher_TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256:         uint16 & 0xC031
_#http2cipher_TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384:         uint16 & 0xC032
_#http2cipher_TLS_ECDHE_PSK_WITH_RC4_128_SHA:               uint16 & 0xC033
_#http2cipher_TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA:          uint16 & 0xC034
_#http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA:           uint16 & 0xC035
_#http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA:           uint16 & 0xC036
_#http2cipher_TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256:        uint16 & 0xC037
_#http2cipher_TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384:        uint16 & 0xC038
_#http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA:                  uint16 & 0xC039
_#http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA256:               uint16 & 0xC03A
_#http2cipher_TLS_ECDHE_PSK_WITH_NULL_SHA384:               uint16 & 0xC03B
_#http2cipher_TLS_RSA_WITH_ARIA_128_CBC_SHA256:             uint16 & 0xC03C
_#http2cipher_TLS_RSA_WITH_ARIA_256_CBC_SHA384:             uint16 & 0xC03D
_#http2cipher_TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256:          uint16 & 0xC03E
_#http2cipher_TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384:          uint16 & 0xC03F
_#http2cipher_TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256:          uint16 & 0xC040
_#http2cipher_TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384:          uint16 & 0xC041
_#http2cipher_TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256:         uint16 & 0xC042
_#http2cipher_TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384:         uint16 & 0xC043
_#http2cipher_TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256:         uint16 & 0xC044
_#http2cipher_TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384:         uint16 & 0xC045
_#http2cipher_TLS_DH_anon_WITH_ARIA_128_CBC_SHA256:         uint16 & 0xC046
_#http2cipher_TLS_DH_anon_WITH_ARIA_256_CBC_SHA384:         uint16 & 0xC047
_#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256:     uint16 & 0xC048
_#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384:     uint16 & 0xC049
_#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256:      uint16 & 0xC04A
_#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384:      uint16 & 0xC04B
_#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256:       uint16 & 0xC04C
_#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384:       uint16 & 0xC04D
_#http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256:        uint16 & 0xC04E
_#http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384:        uint16 & 0xC04F
_#http2cipher_TLS_RSA_WITH_ARIA_128_GCM_SHA256:             uint16 & 0xC050
_#http2cipher_TLS_RSA_WITH_ARIA_256_GCM_SHA384:             uint16 & 0xC051
_#http2cipher_TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256:         uint16 & 0xC052
_#http2cipher_TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384:         uint16 & 0xC053
_#http2cipher_TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256:          uint16 & 0xC054
_#http2cipher_TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384:          uint16 & 0xC055
_#http2cipher_TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256:         uint16 & 0xC056
_#http2cipher_TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384:         uint16 & 0xC057
_#http2cipher_TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256:          uint16 & 0xC058
_#http2cipher_TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384:          uint16 & 0xC059
_#http2cipher_TLS_DH_anon_WITH_ARIA_128_GCM_SHA256:         uint16 & 0xC05A
_#http2cipher_TLS_DH_anon_WITH_ARIA_256_GCM_SHA384:         uint16 & 0xC05B
_#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256:     uint16 & 0xC05C
_#http2cipher_TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384:     uint16 & 0xC05D
_#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256:      uint16 & 0xC05E
_#http2cipher_TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384:      uint16 & 0xC05F
_#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256:       uint16 & 0xC060
_#http2cipher_TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384:       uint16 & 0xC061
_#http2cipher_TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256:        uint16 & 0xC062
_#http2cipher_TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384:        uint16 & 0xC063
_#http2cipher_TLS_PSK_WITH_ARIA_128_CBC_SHA256:             uint16 & 0xC064
_#http2cipher_TLS_PSK_WITH_ARIA_256_CBC_SHA384:             uint16 & 0xC065
_#http2cipher_TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256:         uint16 & 0xC066
_#http2cipher_TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384:         uint16 & 0xC067
_#http2cipher_TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256:         uint16 & 0xC068
_#http2cipher_TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384:         uint16 & 0xC069
_#http2cipher_TLS_PSK_WITH_ARIA_128_GCM_SHA256:             uint16 & 0xC06A
_#http2cipher_TLS_PSK_WITH_ARIA_256_GCM_SHA384:             uint16 & 0xC06B
_#http2cipher_TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256:         uint16 & 0xC06C
_#http2cipher_TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384:         uint16 & 0xC06D
_#http2cipher_TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256:         uint16 & 0xC06E
_#http2cipher_TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384:         uint16 & 0xC06F
_#http2cipher_TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256:       uint16 & 0xC070
_#http2cipher_TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384:       uint16 & 0xC071
_#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: uint16 & 0xC072
_#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: uint16 & 0xC073
_#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256:  uint16 & 0xC074
_#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384:  uint16 & 0xC075
_#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256:   uint16 & 0xC076
_#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384:   uint16 & 0xC077
_#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256:    uint16 & 0xC078
_#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384:    uint16 & 0xC079
_#http2cipher_TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256:         uint16 & 0xC07A
_#http2cipher_TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384:         uint16 & 0xC07B
_#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:     uint16 & 0xC07C
_#http2cipher_TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:     uint16 & 0xC07D
_#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256:      uint16 & 0xC07E
_#http2cipher_TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384:      uint16 & 0xC07F
_#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256:     uint16 & 0xC080
_#http2cipher_TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384:     uint16 & 0xC081
_#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256:      uint16 & 0xC082
_#http2cipher_TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384:      uint16 & 0xC083
_#http2cipher_TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256:     uint16 & 0xC084
_#http2cipher_TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384:     uint16 & 0xC085
_#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: uint16 & 0xC086
_#http2cipher_TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: uint16 & 0xC087
_#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256:  uint16 & 0xC088
_#http2cipher_TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384:  uint16 & 0xC089
_#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256:   uint16 & 0xC08A
_#http2cipher_TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384:   uint16 & 0xC08B
_#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256:    uint16 & 0xC08C
_#http2cipher_TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384:    uint16 & 0xC08D
_#http2cipher_TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256:         uint16 & 0xC08E
_#http2cipher_TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384:         uint16 & 0xC08F
_#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256:     uint16 & 0xC090
_#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384:     uint16 & 0xC091
_#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256:     uint16 & 0xC092
_#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384:     uint16 & 0xC093
_#http2cipher_TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256:         uint16 & 0xC094
_#http2cipher_TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384:         uint16 & 0xC095
_#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256:     uint16 & 0xC096
_#http2cipher_TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:     uint16 & 0xC097
_#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256:     uint16 & 0xC098
_#http2cipher_TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384:     uint16 & 0xC099
_#http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256:   uint16 & 0xC09A
_#http2cipher_TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384:   uint16 & 0xC09B
_#http2cipher_TLS_RSA_WITH_AES_128_CCM:                     uint16 & 0xC09C
_#http2cipher_TLS_RSA_WITH_AES_256_CCM:                     uint16 & 0xC09D
_#http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM:                 uint16 & 0xC09E
_#http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM:                 uint16 & 0xC09F
_#http2cipher_TLS_RSA_WITH_AES_128_CCM_8:                   uint16 & 0xC0A0
_#http2cipher_TLS_RSA_WITH_AES_256_CCM_8:                   uint16 & 0xC0A1
_#http2cipher_TLS_DHE_RSA_WITH_AES_128_CCM_8:               uint16 & 0xC0A2
_#http2cipher_TLS_DHE_RSA_WITH_AES_256_CCM_8:               uint16 & 0xC0A3
_#http2cipher_TLS_PSK_WITH_AES_128_CCM:                     uint16 & 0xC0A4
_#http2cipher_TLS_PSK_WITH_AES_256_CCM:                     uint16 & 0xC0A5
_#http2cipher_TLS_DHE_PSK_WITH_AES_128_CCM:                 uint16 & 0xC0A6
_#http2cipher_TLS_DHE_PSK_WITH_AES_256_CCM:                 uint16 & 0xC0A7
_#http2cipher_TLS_PSK_WITH_AES_128_CCM_8:                   uint16 & 0xC0A8
_#http2cipher_TLS_PSK_WITH_AES_256_CCM_8:                   uint16 & 0xC0A9
_#http2cipher_TLS_PSK_DHE_WITH_AES_128_CCM_8:               uint16 & 0xC0AA
_#http2cipher_TLS_PSK_DHE_WITH_AES_256_CCM_8:               uint16 & 0xC0AB
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM:             uint16 & 0xC0AC
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM:             uint16 & 0xC0AD
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8:           uint16 & 0xC0AE
_#http2cipher_TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8:           uint16 & 0xC0AF

// Unassigned uint16 =  0xC0B0-FF
// Unassigned uint16 =  0xC1-CB,*
// Unassigned uint16 =  0xCC00-A7
_#http2cipher_TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256:   uint16 & 0xCCA8
_#http2cipher_TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: uint16 & 0xCCA9
_#http2cipher_TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256:     uint16 & 0xCCAA
_#http2cipher_TLS_PSK_WITH_CHACHA20_POLY1305_SHA256:         uint16 & 0xCCAB
_#http2cipher_TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256:   uint16 & 0xCCAC
_#http2cipher_TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256:     uint16 & 0xCCAD
_#http2cipher_TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256:     uint16 & 0xCCAE

// ClientConnPool manages a pool of HTTP/2 client connections.
_#http2ClientConnPool: _

// clientConnPoolIdleCloser is the interface implemented by ClientConnPool
// implementations which can close their idle connections.
_#http2clientConnPoolIdleCloser: _

_#http2dialOnMiss:   true
_#http2noDialOnMiss: false

// An ErrCode is an unsigned 32-bit error code as defined in the HTTP/2 spec.
_#http2ErrCode: uint32

_#http2ErrCodeNo:                 _#http2ErrCode & 0x0
_#http2ErrCodeProtocol:           _#http2ErrCode & 0x1
_#http2ErrCodeInternal:           _#http2ErrCode & 0x2
_#http2ErrCodeFlowControl:        _#http2ErrCode & 0x3
_#http2ErrCodeSettingsTimeout:    _#http2ErrCode & 0x4
_#http2ErrCodeStreamClosed:       _#http2ErrCode & 0x5
_#http2ErrCodeFrameSize:          _#http2ErrCode & 0x6
_#http2ErrCodeRefusedStream:      _#http2ErrCode & 0x7
_#http2ErrCodeCancel:             _#http2ErrCode & 0x8
_#http2ErrCodeCompression:        _#http2ErrCode & 0x9
_#http2ErrCodeConnect:            _#http2ErrCode & 0xa
_#http2ErrCodeEnhanceYourCalm:    _#http2ErrCode & 0xb
_#http2ErrCodeInadequateSecurity: _#http2ErrCode & 0xc
_#http2ErrCodeHTTP11Required:     _#http2ErrCode & 0xd

// ConnectionError is an error that results in the termination of the
// entire connection.
_#http2ConnectionError: _#http2ErrCode

// StreamError is an error that only affects one stream within an
// HTTP/2 connection.
_#http2StreamError: {
	StreamID: uint32
	Code:     _#http2ErrCode
	Cause:    _ @go(,error)
}

// 6.9.1 The Flow Control Window
// "If a sender receives a WINDOW_UPDATE that causes a flow control
// window to exceed this maximum it MUST terminate either the stream
// or the connection, as appropriate. For streams, [...]; for the
// connection, a GOAWAY frame with a FLOW_CONTROL_ERROR code."
_#http2goAwayFlowError: {
}

// connError represents an HTTP/2 ConnectionError error code, along
// with a string (for debugging) explaining why.
//
// Errors of this type are only returned by the frame parser functions
// and converted into ConnectionError(Code), after stashing away
// the Reason into the Framer's errDetail field, accessible via
// the (*Framer).ErrorDetail method.
_#http2connError: {
	Code:   _#http2ErrCode
	Reason: string
}

_#http2pseudoHeaderError: string

_#http2duplicatePseudoHeaderError: string

_#http2headerFieldNameError: string

_#http2headerFieldValueError: string

_#http2frameHeaderLen: 9

// A FrameType is a registered frame type as defined in
// https://httpwg.org/specs/rfc7540.html#rfc.section.11.2
_#http2FrameType: uint8

_#http2FrameData:         _#http2FrameType & 0x0
_#http2FrameHeaders:      _#http2FrameType & 0x1
_#http2FramePriority:     _#http2FrameType & 0x2
_#http2FrameRSTStream:    _#http2FrameType & 0x3
_#http2FrameSettings:     _#http2FrameType & 0x4
_#http2FramePushPromise:  _#http2FrameType & 0x5
_#http2FramePing:         _#http2FrameType & 0x6
_#http2FrameGoAway:       _#http2FrameType & 0x7
_#http2FrameWindowUpdate: _#http2FrameType & 0x8
_#http2FrameContinuation: _#http2FrameType & 0x9

// Flags is a bitmask of HTTP/2 flags.
// The meaning of flags varies depending on the frame type.
_#http2Flags: uint8

// Data Frame
_#http2FlagDataEndStream: _#http2Flags & 0x1
_#http2FlagDataPadded:    _#http2Flags & 0x8

// Headers Frame
_#http2FlagHeadersEndStream:  _#http2Flags & 0x1
_#http2FlagHeadersEndHeaders: _#http2Flags & 0x4
_#http2FlagHeadersPadded:     _#http2Flags & 0x8
_#http2FlagHeadersPriority:   _#http2Flags & 0x20

// Settings Frame
_#http2FlagSettingsAck: _#http2Flags & 0x1

// Ping Frame
_#http2FlagPingAck: _#http2Flags & 0x1

// Continuation Frame
_#http2FlagContinuationEndHeaders: _#http2Flags & 0x4
_#http2FlagPushPromiseEndHeaders:  _#http2Flags & 0x4
_#http2FlagPushPromisePadded:      _#http2Flags & 0x8

// A FrameHeader is the 9 byte header of all HTTP/2 frames.
//
// See https://httpwg.org/specs/rfc7540.html#FrameHeader
_#http2FrameHeader: {
	// Type is the 1 byte frame type. There are ten standard frame
	// types, but extension frame types may be written by WriteRawFrame
	// and will be returned by ReadFrame (as UnknownFrame).
	Type: _#http2FrameType

	// Flags are the 1 byte of 8 potential bit flags per frame.
	// They are specific to the frame type.
	Flags: _#http2Flags

	// Length is the length of the frame, not including the 9 byte header.
	// The maximum size is one byte less than 16MB (uint24), but only
	// frames up to 16KB are allowed without peer agreement.
	Length: uint32

	// StreamID is which stream this frame is for. Certain frames
	// are not stream-specific, in which case this field is 0.
	StreamID: uint32
}

// A Frame is the base interface implemented by all frame types.
// Callers will generally type-assert the specific frame type:
// *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.
//
// Frames are only valid until the next call to Framer.ReadFrame.
_#http2Frame: _

// A Framer reads and writes Frames.
_#http2Framer: {
	// AllowIllegalWrites permits the Framer's Write methods to
	// write frames that do not conform to the HTTP/2 spec. This
	// permits using the Framer to test other HTTP/2
	// implementations' conformance to the spec.
	// If false, the Write methods will prefer to return an error
	// rather than comply.
	AllowIllegalWrites: bool

	// AllowIllegalReads permits the Framer's ReadFrame method
	// to return non-compliant frames or frame orders.
	// This is for testing and permits using the Framer to test
	// other HTTP/2 implementations' conformance to the spec.
	// It is not compatible with ReadMetaHeaders.
	AllowIllegalReads: bool

	// MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.
	// It's used only if ReadMetaHeaders is set; 0 means a sane default
	// (currently 16MB)
	// If the limit is hit, MetaHeadersFrame.Truncated is set true.
	MaxHeaderListSize: uint32
}

_#http2minMaxFrameSize: 16384
_#http2maxFrameSize:    16777215

// A PingFrame is a mechanism for measuring a minimal round trip time
// from the sender, as well as determining whether an idle connection
// is still functional.
// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.7
_#http2PingFrame: {
	Data: bytes @go(,[8]byte)
}

// A GoAwayFrame informs the remote peer to stop creating streams on this connection.
// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.8
_#http2GoAwayFrame: {
	LastStreamID: uint32
	ErrCode:      _#http2ErrCode
}

// A WindowUpdateFrame is used to implement flow control.
// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.9
_#http2WindowUpdateFrame: {
	Increment: uint32
}

// A HeadersFrame is used to open a stream and additionally carries a
// header block fragment.
_#http2HeadersFrame: {
	// Priority is set if FlagHeadersPriority is set in the FrameHeader.
	Priority: _#http2PriorityParam
}

// HeadersFrameParam are the parameters for writing a HEADERS frame.
_#http2HeadersFrameParam: {
	// StreamID is the required Stream ID to initiate.
	StreamID: uint32

	// BlockFragment is part (or all) of a Header Block.
	BlockFragment: bytes @go(,[]byte)

	// EndStream indicates that the header block is the last that
	// the endpoint will send for the identified stream. Setting
	// this flag causes the stream to enter one of "half closed"
	// states.
	EndStream: bool

	// EndHeaders indicates that this frame contains an entire
	// header block and is not followed by any
	// CONTINUATION frames.
	EndHeaders: bool

	// PadLength is the optional number of bytes of zeros to add
	// to this frame.
	PadLength: uint8

	// Priority, if non-zero, includes stream priority information
	// in the HEADER frame.
	Priority: _#http2PriorityParam
}

// PriorityParam are the stream prioritzation parameters.
_#http2PriorityParam: {
	// StreamDep is a 31-bit stream identifier for the
	// stream that this stream depends on. Zero means no
	// dependency.
	StreamDep: uint32

	// Exclusive is whether the dependency is exclusive.
	Exclusive: bool

	// Weight is the stream's zero-indexed weight. It should be
	// set together with StreamDep, or neither should be set. Per
	// the spec, "Add one to the value to obtain a weight between
	// 1 and 256."
	Weight: uint8
}

// A RSTStreamFrame allows for abnormal termination of a stream.
// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.4
_#http2RSTStreamFrame: {
	ErrCode: _#http2ErrCode
}

// A PushPromiseFrame is used to initiate a server stream.
// See https://httpwg.org/specs/rfc7540.html#rfc.section.6.6
_#http2PushPromiseFrame: {
	PromiseID: uint32
}

// PushPromiseParam are the parameters for writing a PUSH_PROMISE frame.
_#http2PushPromiseParam: {
	// StreamID is the required Stream ID to initiate.
	StreamID: uint32

	// PromiseID is the required Stream ID which this
	// Push Promises
	PromiseID: uint32

	// BlockFragment is part (or all) of a Header Block.
	BlockFragment: bytes @go(,[]byte)

	// EndHeaders indicates that this frame contains an entire
	// header block and is not followed by any
	// CONTINUATION frames.
	EndHeaders: bool

	// PadLength is the optional number of bytes of zeros to add
	// to this frame.
	PadLength: uint8
}

_#http2streamEnder: _

_#http2headersEnder: _

_#http2headersOrContinuation: _

// A MetaHeadersFrame is the representation of one HEADERS frame and
// zero or more contiguous CONTINUATION frames and the decoding of
// their HPACK-encoded contents.
//
// This type of frame does not appear on the wire and is only returned
// by the Framer when Framer.ReadMetaHeaders is set.
_#http2MetaHeadersFrame: {
	// Fields are the fields contained in the HEADERS and
	// CONTINUATION frames. The underlying slice is owned by the
	// Framer and must not be retained after the next call to
	// ReadFrame.
	//
	// Fields are guaranteed to be in the correct http2 order and
	// not have unknown pseudo header fields or invalid header
	// field names or values. Required pseudo header fields may be
	// missing, however. Use the MetaHeadersFrame.Pseudo accessor
	// method access pseudo headers.
	Fields: [...hpack.#HeaderField] @go(,[]vendor/hpack.HeaderField)

	// Truncated is whether the max header list size limit was hit
	// and Fields is incomplete. The hpack decoder state is still
	// valid, however.
	Truncated: bool
}

_#http2goroutineLock: uint64

// ClientPreface is the string that must be sent by new
// connections from clients.
_#http2ClientPreface: "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"

// SETTINGS_MAX_FRAME_SIZE default
// https://httpwg.org/specs/rfc7540.html#rfc.section.6.5.2
_#http2initialMaxFrameSize: 16384

// NextProtoTLS is the NPN/ALPN protocol negotiated during
// HTTP/2's TLS setup.
_#http2NextProtoTLS: "h2"

// https://httpwg.org/specs/rfc7540.html#SettingValues
_#http2initialHeaderTableSize:  4096
_#http2initialWindowSize:       65535
_#http2defaultMaxReadFrameSize: 1048576

_#http2streamState: int

_#http2stateIdle:             _#http2streamState & 0
_#http2stateOpen:             _#http2streamState & 1
_#http2stateHalfClosedLocal:  _#http2streamState & 2
_#http2stateHalfClosedRemote: _#http2streamState & 3
_#http2stateClosed:           _#http2streamState & 4

// Setting is a setting parameter: which setting it is, and its value.
_#http2Setting: {
	// ID is which setting is being set.
	// See https://httpwg.org/specs/rfc7540.html#SettingFormat
	ID: _#http2SettingID

	// Val is the value.
	Val: uint32
}

// A SettingID is an HTTP/2 setting as defined in
// https://httpwg.org/specs/rfc7540.html#iana-settings
_#http2SettingID: uint16

_#http2SettingHeaderTableSize:      _#http2SettingID & 0x1
_#http2SettingEnablePush:           _#http2SettingID & 0x2
_#http2SettingMaxConcurrentStreams: _#http2SettingID & 0x3
_#http2SettingInitialWindowSize:    _#http2SettingID & 0x4
_#http2SettingMaxFrameSize:         _#http2SettingID & 0x5
_#http2SettingMaxHeaderListSize:    _#http2SettingID & 0x6

// from pkg io
_#http2stringWriter: _

_#http2bufWriterPoolBufferSize: 4096

_#http2connectionStater: _

_#http2pipeBuffer: _

_#http2prefaceTimeout:         time.#Duration & 10000000000
_#http2firstSettingsTimeout:   time.#Duration & 2000000000
_#http2handlerChunkWriteSize:  4096
_#http2defaultMaxStreams:      250
_#http2maxQueuedControlFrames: 10000

// Server is an HTTP/2 server.
_#http2Server: {
	// MaxHandlers limits the number of http.Handler ServeHTTP goroutines
	// which may run at a time over all connections.
	// Negative or zero no limit.
	// TODO: implement
	MaxHandlers: int

	// MaxConcurrentStreams optionally specifies the number of
	// concurrent streams that each client may have open at a
	// time. This is unrelated to the number of http.Handler goroutines
	// which may be active globally, which is MaxHandlers.
	// If zero, MaxConcurrentStreams defaults to at least 100, per
	// the HTTP/2 spec's recommendations.
	MaxConcurrentStreams: uint32

	// MaxDecoderHeaderTableSize optionally specifies the http2
	// SETTINGS_HEADER_TABLE_SIZE to send in the initial settings frame. It
	// informs the remote endpoint of the maximum size of the header compression
	// table used to decode header blocks, in octets. If zero, the default value
	// of 4096 is used.
	MaxDecoderHeaderTableSize: uint32

	// MaxEncoderHeaderTableSize optionally specifies an upper limit for the
	// header compression table used for encoding request headers. Received
	// SETTINGS_HEADER_TABLE_SIZE settings are capped at this limit. If zero,
	// the default value of 4096 is used.
	MaxEncoderHeaderTableSize: uint32

	// MaxReadFrameSize optionally specifies the largest frame
	// this server is willing to read. A valid value is between
	// 16k and 16M, inclusive. If zero or otherwise invalid, a
	// default value is used.
	MaxReadFrameSize: uint32

	// PermitProhibitedCipherSuites, if true, permits the use of
	// cipher suites prohibited by the HTTP/2 spec.
	PermitProhibitedCipherSuites: bool

	// IdleTimeout specifies how long until idle clients should be
	// closed with a GOAWAY frame. PING frames are not considered
	// activity for the purposes of IdleTimeout.
	IdleTimeout: time.#Duration

	// MaxUploadBufferPerConnection is the size of the initial flow
	// control window for each connections. The HTTP/2 spec does not
	// allow this to be smaller than 65535 or larger than 2^32-1.
	// If the value is outside this range, a default value will be
	// used instead.
	MaxUploadBufferPerConnection: int32

	// MaxUploadBufferPerStream is the size of the initial flow control
	// window for each stream. The HTTP/2 spec does not allow this to
	// be larger than 2^32-1. If the value is zero or larger than the
	// maximum, a default value will be used instead.
	MaxUploadBufferPerStream: int32
}

// ServeConnOpts are options for the Server.ServeConn method.
_#http2ServeConnOpts: {
	// Context is the base context to use.
	// If nil, context.Background is used.
	Context: context.#Context

	// BaseConfig optionally sets the base configuration
	// for values. If nil, defaults are used.
	BaseConfig?: null | #Server @go(,*Server)

	// Handler specifies which handler to use for processing
	// requests. If nil, BaseConfig.Handler is used. If BaseConfig
	// or BaseConfig.Handler is nil, http.DefaultServeMux is used.
	Handler: #Handler

	// UpgradeRequest is an initial request received on a connection
	// undergoing an h2c upgrade. The request body must have been
	// completely read from the connection before calling ServeConn,
	// and the 101 Switching Protocols response written.
	UpgradeRequest?: null | #Request @go(,*Request)

	// Settings is the decoded contents of the HTTP2-Settings header
	// in an h2c upgrade request.
	Settings: bytes @go(,[]byte)

	// SawClientPreface is set if the HTTP/2 connection preface
	// has already been read from the connection.
	SawClientPreface: bool
}

_#http2maxCachedCanonicalHeadersKeysSize: 2048

_#http2serverMessage: int

_#http2TrailerPrefix: "Trailer:"

// transportDefaultConnFlow is how many connection-level flow control
// tokens we give the server at start-up, past the default 64k.
_#http2transportDefaultConnFlow: 1073741824

// transportDefaultStreamFlow is how many stream-level flow
// control tokens we announce to the peer, and how many bytes
// we buffer per stream.
_#http2transportDefaultStreamFlow: 4194304

// transportDefaultStreamMinRefresh is the minimum number of bytes we'll send
// a stream-level WINDOW_UPDATE for at a time.
_#http2transportDefaultStreamMinRefresh: 4096
_#http2defaultUserAgent:                 "Go-http-client/2.0"

// initialMaxConcurrentStreams is a connections maxConcurrentStreams until
// it's received servers initial SETTINGS frame, which corresponds with the
// spec's minimum recommended value.
_#http2initialMaxConcurrentStreams: 100

// defaultMaxConcurrentStreams is a connections default maxConcurrentStreams
// if the server doesn't include one in its initial SETTINGS frame.
_#http2defaultMaxConcurrentStreams: 1000

// Transport is an HTTP/2 Transport.
//
// A Transport internally caches connections to servers. It is safe
// for concurrent use by multiple goroutines.
_#http2Transport: {
	// TLSClientConfig specifies the TLS configuration to use with
	// tls.Client. If nil, the default configuration is used.
	TLSClientConfig?: null | tls.#Config @go(,*tls.Config)

	// ConnPool optionally specifies an alternate connection pool to use.
	// If nil, the default is used.
	ConnPool: _#http2ClientConnPool

	// DisableCompression, if true, prevents the Transport from
	// requesting compression with an "Accept-Encoding: gzip"
	// request header when the Request contains no existing
	// Accept-Encoding value. If the Transport requests gzip on
	// its own and gets a gzipped response, it's transparently
	// decoded in the Response.Body. However, if the user
	// explicitly requested gzip it is not automatically
	// uncompressed.
	DisableCompression: bool

	// AllowHTTP, if true, permits HTTP/2 requests using the insecure,
	// plain-text "http" scheme. Note that this does not enable h2c support.
	AllowHTTP: bool

	// MaxHeaderListSize is the http2 SETTINGS_MAX_HEADER_LIST_SIZE to
	// send in the initial settings frame. It is how many bytes
	// of response headers are allowed. Unlike the http2 spec, zero here
	// means to use a default limit (currently 10MB). If you actually
	// want to advertise an unlimited value to the peer, Transport
	// interprets the highest possible value here (0xffffffff or 1<<32-1)
	// to mean no limit.
	MaxHeaderListSize: uint32

	// MaxReadFrameSize is the http2 SETTINGS_MAX_FRAME_SIZE to send in the
	// initial settings frame. It is the size in bytes of the largest frame
	// payload that the sender is willing to receive. If 0, no setting is
	// sent, and the value is provided by the peer, which should be 16384
	// according to the spec:
	// https://datatracker.ietf.org/doc/html/rfc7540#section-6.5.2.
	// Values are bounded in the range 16k to 16M.
	MaxReadFrameSize: uint32

	// MaxDecoderHeaderTableSize optionally specifies the http2
	// SETTINGS_HEADER_TABLE_SIZE to send in the initial settings frame. It
	// informs the remote endpoint of the maximum size of the header compression
	// table used to decode header blocks, in octets. If zero, the default value
	// of 4096 is used.
	MaxDecoderHeaderTableSize: uint32

	// MaxEncoderHeaderTableSize optionally specifies an upper limit for the
	// header compression table used for encoding request headers. Received
	// SETTINGS_HEADER_TABLE_SIZE settings are capped at this limit. If zero,
	// the default value of 4096 is used.
	MaxEncoderHeaderTableSize: uint32

	// StrictMaxConcurrentStreams controls whether the server's
	// SETTINGS_MAX_CONCURRENT_STREAMS should be respected
	// globally. If false, new TCP connections are created to the
	// server as needed to keep each under the per-connection
	// SETTINGS_MAX_CONCURRENT_STREAMS limit. If true, the
	// server's SETTINGS_MAX_CONCURRENT_STREAMS is interpreted as
	// a global limit and callers of RoundTrip block when needed,
	// waiting for their turn.
	StrictMaxConcurrentStreams: bool

	// ReadIdleTimeout is the timeout after which a health check using ping
	// frame will be carried out if no frame is received on the connection.
	// Note that a ping response will is considered a received frame, so if
	// there is no other traffic on the connection, the health check will
	// be performed every ReadIdleTimeout interval.
	// If zero, no health check is performed.
	ReadIdleTimeout: time.#Duration

	// PingTimeout is the timeout after which the connection will be closed
	// if a response to Ping is not received.
	// Defaults to 15s.
	PingTimeout: time.#Duration

	// WriteByteTimeout is the timeout after which the connection will be
	// closed no data can be written to it. The timeout begins when data is
	// available to write, and is extended whenever any bytes are written.
	WriteByteTimeout: time.#Duration
}

// clientStream is the state for a single HTTP/2 stream. One of these
// is created for each Transport.RoundTrip call.
_#http2clientStream: {
	ID: uint32
}

// noCachedConnError is the concrete type of ErrNoCachedConn, which
// needs to be detected by net/http regardless of whether it's its
// bundled version (in h2_bundle.go with a rewritten type name) or
// from a user's x/net/http2. As such, as it has a unique method name
// (IsHTTP2NoCachedConnError) that net/http sniffs for via func
// isNoCachedConnError.
_#http2noCachedConnError: {
}

// RoundTripOpt are options for the Transport.RoundTripOpt method.
_#http2RoundTripOpt: {
	// OnlyCachedConn controls whether RoundTripOpt may
	// create a new TCP connection. If set true and
	// no cached connection is available, RoundTripOpt
	// will return ErrNoCachedConn.
	OnlyCachedConn: bool
}

// ClientConnState describes the state of a ClientConn.
_#http2ClientConnState: {
	// Closed is whether the connection is closed.
	Closed: bool

	// Closing is whether the connection is in the process of
	// closing. It may be closing due to shutdown, being a
	// single-use connection, being marked as DoNotReuse, or
	// having received a GOAWAY frame.
	Closing: bool

	// StreamsActive is how many streams are active.
	StreamsActive: int

	// StreamsReserved is how many streams have been reserved via
	// ClientConn.ReserveNewRequest.
	StreamsReserved: int

	// StreamsPending is how many requests have been sent in excess
	// of the peer's advertised MaxConcurrentStreams setting and
	// are waiting for other streams to complete.
	StreamsPending: int

	// MaxConcurrentStreams is how many concurrent streams the
	// peer advertised as acceptable. Zero means no SETTINGS
	// frame has been received yet.
	MaxConcurrentStreams: uint32

	// LastIdle, if non-zero, is when the connection last
	// transitioned to idle state.
	LastIdle: time.Time
}

// GoAwayError is returned by the Transport when the server closes the
// TCP connection after sending a GOAWAY frame.
_#http2GoAwayError: {
	LastStreamID: uint32
	ErrCode:      _#http2ErrCode
	DebugData:    string
}

_#http2noBodyReader: {
}

_#http2missingBody: {
}

// writeFramer is implemented by any type that is used to write frames.
_#http2writeFramer: _

// writeContext is the interface needed by the various frame writer
// types below. All the writeFrame methods below are scheduled via the
// frame writing scheduler (see writeScheduler in writesched.go).
//
// This interface is implemented by *serverConn.
//
// TODO: decide whether to a) use this in the client code (which didn't
// end up using this yet, because it has a simpler design, not
// currently implementing priorities), or b) delete this and
// make the server code a bit more concrete.
_#http2writeContext: _

_#http2flushFrameWriter: {
}

_#http2writeSettings: [..._#http2Setting]

// handlerPanicRST is the message sent from handler goroutines when
// the handler panics.
_#http2handlerPanicRST: {
	StreamID: uint32
}

_#http2writeSettingsAck: {
}

// WriteScheduler is the interface implemented by HTTP/2 write schedulers.
// Methods are never called concurrently.
_#http2WriteScheduler: _

// OpenStreamOptions specifies extra options for WriteScheduler.OpenStream.
_#http2OpenStreamOptions: {
	// PusherID is zero if the stream was initiated by the client. Otherwise,
	// PusherID names the stream that pushed the newly opened stream.
	PusherID: uint32
}

_#http2priorityDefaultWeight: 15

// PriorityWriteSchedulerConfig configures a priorityWriteScheduler.
_#http2PriorityWriteSchedulerConfig: {
	// MaxClosedNodesInTree controls the maximum number of closed streams to
	// retain in the priority tree. Setting this to zero saves a small amount
	// of memory at the cost of performance.
	//
	// See RFC 7540, Section 5.3.4:
	//   "It is possible for a stream to become closed while prioritization
	//   information ... is in transit. ... This potentially creates suboptimal
	//   prioritization, since the stream could be given a priority that is
	//   different from what is intended. To avoid these problems, an endpoint
	//   SHOULD retain stream prioritization state for a period after streams
	//   become closed. The longer state is retained, the lower the chance that
	//   streams are assigned incorrect or default priority values."
	MaxClosedNodesInTree: int

	// MaxIdleNodesInTree controls the maximum number of idle streams to
	// retain in the priority tree. Setting this to zero saves a small amount
	// of memory at the cost of performance.
	//
	// See RFC 7540, Section 5.3.4:
	//   Similarly, streams that are in the "idle" state can be assigned
	//   priority or become a parent of other streams. This allows for the
	//   creation of a grouping node in the dependency tree, which enables
	//   more flexible expressions of priority. Idle streams begin with a
	//   default priority (Section 5.3.5).
	MaxIdleNodesInTree: int

	// ThrottleOutOfOrderWrites enables write throttling to help ensure that
	// data is delivered in priority order. This works around a race where
	// stream B depends on stream A and both streams are about to call Write
	// to queue DATA frames. If B wins the race, a naive scheduler would eagerly
	// write as much data from B as possible, but this is suboptimal because A
	// is a higher-priority stream. With throttling enabled, we write a small
	// amount of data from B to minimize the amount of bandwidth that B can
	// steal from A.
	ThrottleOutOfOrderWrites: bool
}

_#http2priorityNodeState: int

_#http2priorityNodeOpen:   _#http2priorityNodeState & 0
_#http2priorityNodeClosed: _#http2priorityNodeState & 1
_#http2priorityNodeIdle:   _#http2priorityNodeState & 2
