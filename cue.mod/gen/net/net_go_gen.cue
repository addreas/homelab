// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go net

// Package net provides a portable interface for network I/O, including
// TCP/IP, UDP, domain name resolution, and Unix domain sockets.
//
// Although the package provides access to low-level networking
// primitives, most clients will need only the basic interface provided
// by the Dial, Listen, and Accept functions and the associated
// Conn and Listener interfaces. The crypto/tls package uses
// the same interfaces and similar Dial and Listen functions.
//
// The Dial function connects to a server:
//
//  conn, err := net.Dial("tcp", "golang.org:80")
//  if err != nil {
//   // handle error
//  }
//  fmt.Fprintf(conn, "GET / HTTP/1.0\r\n\r\n")
//  status, err := bufio.NewReader(conn).ReadString('\n')
//  // ...
//
// The Listen function creates servers:
//
//  ln, err := net.Listen("tcp", ":8080")
//  if err != nil {
//   // handle error
//  }
//  for {
//   conn, err := ln.Accept()
//   if err != nil {
//    // handle error
//   }
//   go handleConnection(conn)
//  }
//
// # Name Resolution
//
// The method for resolving domain names, whether indirectly with functions like Dial
// or directly with functions like LookupHost and LookupAddr, varies by operating system.
//
// On Unix systems, the resolver has two options for resolving names.
// It can use a pure Go resolver that sends DNS requests directly to the servers
// listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C
// library routines such as getaddrinfo and getnameinfo.
//
// By default the pure Go resolver is used, because a blocked DNS request consumes
// only a goroutine, while a blocked C call consumes an operating system thread.
// When cgo is available, the cgo-based resolver is used instead under a variety of
// conditions: on systems that do not let programs make direct DNS requests (OS X),
// when the LOCALDOMAIN environment variable is present (even if empty),
// when the RES_OPTIONS or HOSTALIASES environment variable is non-empty,
// when the ASR_CONFIG environment variable is non-empty (OpenBSD only),
// when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the
// Go resolver does not implement, and when the name being looked up ends in .local
// or is an mDNS name.
//
// The resolver decision can be overridden by setting the netdns value of the
// GODEBUG environment variable (see package runtime) to go or cgo, as in:
//
//  export GODEBUG=netdns=go    # force pure Go resolver
//  export GODEBUG=netdns=cgo   # force native resolver (cgo, win32)
//
// The decision can also be forced while building the Go source tree
// by setting the netgo or netcgo build tag.
//
// A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver
// to print debugging information about its decisions.
// To force a particular resolver while also printing debugging information,
// join the two settings by a plus sign, as in GODEBUG=netdns=go+1.
//
// On Plan 9, the resolver always accesses /net/cs and /net/dns.
//
// On Windows, in Go 1.18.x and earlier, the resolver always used C
// library functions, such as GetAddrInfo and DnsQuery.
//
package net

import "io"

// Addr represents a network end point address.
//
// The two methods Network and String conventionally return strings
// that can be passed as the arguments to Dial, but the exact form
// and meaning of the strings is up to the implementation.
#Addr: _

// Conn is a generic stream-oriented network connection.
//
// Multiple goroutines may invoke methods on a Conn simultaneously.
#Conn: _

// PacketConn is a generic packet-oriented network connection.
//
// Multiple goroutines may invoke methods on a PacketConn simultaneously.
#PacketConn: _

// A Listener is a generic network listener for stream-oriented protocols.
//
// Multiple goroutines may invoke methods on a Listener simultaneously.
#Listener: _

// An Error represents a network error.
#Error: _

// canceledError lets us return the same error string we have always
// returned, while still being Is context.Canceled.
_#canceledError: {
}

// OpError is the error type usually returned by functions in the net
// package. It describes the operation, network type, and address of
// an error.
#OpError: {
	// Op is the operation which caused the error, such as
	// "read" or "write".
	Op: string

	// Net is the network type on which this error occurred,
	// such as "tcp" or "udp6".
	Net: string

	// For operations involving a remote network connection, like
	// Dial, Read, or Write, Source is the corresponding local
	// network address.
	Source: #Addr

	// Addr is the network address for which this error occurred.
	// For local operations, like Listen or SetDeadline, Addr is
	// the address of the local endpoint being manipulated.
	// For operations involving a remote network connection, like
	// Dial, Read, or Write, Addr is the remote address of that
	// connection.
	Addr: #Addr

	// Err is the error that occurred during the operation.
	// The Error method panics if the error is nil.
	Err: _ @go(,error)
}

_#timeout: _

_#temporary: _

// A ParseError is the error type of literal network address parsers.
#ParseError: {
	// Type is the type of string that was expected, such as
	// "IP address", "CIDR address".
	Type: string

	// Text is the malformed text string.
	Text: string
}

#AddrError: {
	Err:  string
	Addr: string
}

#UnknownNetworkError: string

#InvalidAddrError: string

_#timeoutError: {
}

// DNSConfigError represents an error reading the machine's DNS configuration.
// (No longer used; kept for compatibility.)
#DNSConfigError: {
	Err: _ @go(,error)
}

// DNSError represents a DNS lookup error.
#DNSError: {
	Err:         string
	Name:        string
	Server:      string
	IsTimeout:   bool
	IsTemporary: bool
	IsNotFound:  bool
}

_#writerOnly: Writer: io.#Writer

// buffersWriter is the interface implemented by Conns that support a
// "writev"-like batch write optimization.
// writeBuffers should fully consume and write all chunks from the
// provided Buffers, else it should report a non-nil error.
_#buffersWriter: _

// Buffers contains zero or more runs of bytes to write.
//
// On certain machines, for certain types of connections, this is
// optimized into an OS-specific batch write operation (such as
// "writev").
#Buffers: [...bytes]
