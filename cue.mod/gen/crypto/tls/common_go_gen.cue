// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go crypto/tls

package tls

import (
	"crypto/x509"
	"net"
	"io"
	"time"
	"crypto"
)

#VersionTLS10: 0x0301
#VersionTLS11: 0x0302
#VersionTLS12: 0x0303
#VersionTLS13: 0x0304

// Deprecated: SSLv3 is cryptographically broken, and is no longer
// supported by this package. See golang.org/issue/32716.
#VersionSSL30: 0x0300

_#maxPlaintext:       16384
_#maxCiphertext:      18432
_#maxCiphertextTLS13: 16640
_#recordHeaderLen:    5
_#maxHandshake:       65536
_#maxUselessRecords:  16

// TLS record types.
_#recordType: uint8

_#recordTypeChangeCipherSpec: _#recordType & 20
_#recordTypeAlert:            _#recordType & 21
_#recordTypeHandshake:        _#recordType & 22
_#recordTypeApplicationData:  _#recordType & 23

_#typeHelloRequest:        uint8 & 0
_#typeClientHello:         uint8 & 1
_#typeServerHello:         uint8 & 2
_#typeNewSessionTicket:    uint8 & 4
_#typeEndOfEarlyData:      uint8 & 5
_#typeEncryptedExtensions: uint8 & 8
_#typeCertificate:         uint8 & 11
_#typeServerKeyExchange:   uint8 & 12
_#typeCertificateRequest:  uint8 & 13
_#typeServerHelloDone:     uint8 & 14
_#typeCertificateVerify:   uint8 & 15
_#typeClientKeyExchange:   uint8 & 16
_#typeFinished:            uint8 & 20
_#typeCertificateStatus:   uint8 & 22
_#typeKeyUpdate:           uint8 & 24
_#typeNextProtocol:        uint8 & 67
_#typeMessageHash:         uint8 & 254

_#compressionNone: uint8 & 0

_#extensionServerName:              uint16 & 0
_#extensionStatusRequest:           uint16 & 5
_#extensionSupportedCurves:         uint16 & 10
_#extensionSupportedPoints:         uint16 & 11
_#extensionSignatureAlgorithms:     uint16 & 13
_#extensionALPN:                    uint16 & 16
_#extensionSCT:                     uint16 & 18
_#extensionSessionTicket:           uint16 & 35
_#extensionPreSharedKey:            uint16 & 41
_#extensionEarlyData:               uint16 & 42
_#extensionSupportedVersions:       uint16 & 43
_#extensionCookie:                  uint16 & 44
_#extensionPSKModes:                uint16 & 45
_#extensionCertificateAuthorities:  uint16 & 47
_#extensionSignatureAlgorithmsCert: uint16 & 50
_#extensionKeyShare:                uint16 & 51
_#extensionRenegotiationInfo:       uint16 & 0xff01

_#scsvRenegotiation: uint16 & 0x00ff

// CurveID is the type of a TLS identifier for an elliptic curve. See
// https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8.
//
// In TLS 1.3, this type is called NamedGroup, but at this time this library
// only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7.
#CurveID: uint16 // #enumCurveID

#enumCurveID:
	#CurveP256 |
	#CurveP384 |
	#CurveP521 |
	#X25519

#values_CurveID: {
	CurveP256: #CurveP256
	CurveP384: #CurveP384
	CurveP521: #CurveP521
	X25519:    #X25519
}

#CurveP256: #CurveID & 23
#CurveP384: #CurveID & 24
#CurveP521: #CurveID & 25
#X25519:    #CurveID & 29

_#pskModePlain: uint8 & 0
_#pskModeDHE:   uint8 & 1

_#pointFormatUncompressed: uint8 & 0

_#statusTypeOCSP: uint8 & 1

_#certTypeRSASign:   1
_#certTypeECDSASign: 64

_#signaturePKCS1v15: uint8 & 225
_#signatureRSAPSS:   uint8 & 226
_#signatureECDSA:    uint8 & 227
_#signatureEd25519:  uint8 & 228

// downgradeCanaryTLS12 or downgradeCanaryTLS11 is embedded in the server
// random as a downgrade protection if the server would be capable of
// negotiating a higher version. See RFC 8446, Section 4.1.3.
_#downgradeCanaryTLS12: "DOWNGRD\x01"
_#downgradeCanaryTLS11: "DOWNGRD\x00"

// ConnectionState records basic TLS details about the connection.
#ConnectionState: {
	// Version is the TLS version used by the connection (e.g. VersionTLS12).
	Version: uint16

	// HandshakeComplete is true if the handshake has concluded.
	HandshakeComplete: bool

	// DidResume is true if this connection was successfully resumed from a
	// previous session with a session ticket or similar mechanism.
	DidResume: bool

	// CipherSuite is the cipher suite negotiated for the connection (e.g.
	// TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256).
	CipherSuite: uint16

	// NegotiatedProtocol is the application protocol negotiated with ALPN.
	NegotiatedProtocol: string

	// NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation.
	//
	// Deprecated: this value is always true.
	NegotiatedProtocolIsMutual: bool

	// ServerName is the value of the Server Name Indication extension sent by
	// the client. It's available both on the server and on the client side.
	ServerName: string

	// PeerCertificates are the parsed certificates sent by the peer, in the
	// order in which they were sent. The first element is the leaf certificate
	// that the connection is verified against.
	//
	// On the client side, it can't be empty. On the server side, it can be
	// empty if Config.ClientAuth is not RequireAnyClientCert or
	// RequireAndVerifyClientCert.
	//
	// PeerCertificates and its contents should not be modified.
	PeerCertificates: [...null | x509.#Certificate] @go(,[]*x509.Certificate)

	// VerifiedChains is a list of one or more chains where the first element is
	// PeerCertificates[0] and the last element is from Config.RootCAs (on the
	// client side) or Config.ClientCAs (on the server side).
	//
	// On the client side, it's set if Config.InsecureSkipVerify is false. On
	// the server side, it's set if Config.ClientAuth is VerifyClientCertIfGiven
	// (and the peer provided a certificate) or RequireAndVerifyClientCert.
	//
	// VerifiedChains and its contents should not be modified.
	VerifiedChains: [...[...null | x509.#Certificate]] @go(,[][]*x509.Certificate)

	// SignedCertificateTimestamps is a list of SCTs provided by the peer
	// through the TLS handshake for the leaf certificate, if any.
	SignedCertificateTimestamps: [...bytes] @go(,[][]byte)

	// OCSPResponse is a stapled Online Certificate Status Protocol (OCSP)
	// response provided by the peer for the leaf certificate, if any.
	OCSPResponse: bytes @go(,[]byte)

	// TLSUnique contains the "tls-unique" channel binding value (see RFC 5929,
	// Section 3). This value will be nil for TLS 1.3 connections and for all
	// resumed connections.
	//
	// Deprecated: there are conditions in which this value might not be unique
	// to a connection. See the Security Considerations sections of RFC 5705 and
	// RFC 7627, and https://mitls.org/pages/attacks/3SHAKE#channelbindings.
	TLSUnique: bytes @go(,[]byte)
}

// ClientAuthType declares the policy the server will follow for
// TLS Client Authentication.
#ClientAuthType: int // #enumClientAuthType

#enumClientAuthType:
	#NoClientCert |
	#RequestClientCert |
	#RequireAnyClientCert |
	#VerifyClientCertIfGiven |
	#RequireAndVerifyClientCert

#values_ClientAuthType: {
	NoClientCert:               #NoClientCert
	RequestClientCert:          #RequestClientCert
	RequireAnyClientCert:       #RequireAnyClientCert
	VerifyClientCertIfGiven:    #VerifyClientCertIfGiven
	RequireAndVerifyClientCert: #RequireAndVerifyClientCert
}

// NoClientCert indicates that no client certificate should be requested
// during the handshake, and if any certificates are sent they will not
// be verified.
#NoClientCert: #ClientAuthType & 0

// RequestClientCert indicates that a client certificate should be requested
// during the handshake, but does not require that the client send any
// certificates.
#RequestClientCert: #ClientAuthType & 1

// RequireAnyClientCert indicates that a client certificate should be requested
// during the handshake, and that at least one certificate is required to be
// sent by the client, but that certificate is not required to be valid.
#RequireAnyClientCert: #ClientAuthType & 2

// VerifyClientCertIfGiven indicates that a client certificate should be requested
// during the handshake, but does not require that the client sends a
// certificate. If the client does send a certificate it is required to be
// valid.
#VerifyClientCertIfGiven: #ClientAuthType & 3

// RequireAndVerifyClientCert indicates that a client certificate should be requested
// during the handshake, and that at least one valid certificate is required
// to be sent by the client.
#RequireAndVerifyClientCert: #ClientAuthType & 4

// ClientSessionCache is a cache of ClientSessionState objects that can be used
// by a client to resume a TLS session with a given server. ClientSessionCache
// implementations should expect to be called concurrently from different
// goroutines. Up to TLS 1.2, only ticket-based resumption is supported, not
// SessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which
// are supported via this interface.
#ClientSessionCache: _

// SignatureScheme identifies a signature algorithm supported by TLS. See
// RFC 8446, Section 4.2.3.
#SignatureScheme: uint16 // #enumSignatureScheme

#enumSignatureScheme:
	#PKCS1WithSHA256 |
	#PKCS1WithSHA384 |
	#PKCS1WithSHA512 |
	#PSSWithSHA256 |
	#PSSWithSHA384 |
	#PSSWithSHA512 |
	#ECDSAWithP256AndSHA256 |
	#ECDSAWithP384AndSHA384 |
	#ECDSAWithP521AndSHA512 |
	#Ed25519 |
	#PKCS1WithSHA1 |
	#ECDSAWithSHA1

#values_SignatureScheme: {
	PKCS1WithSHA256:        #PKCS1WithSHA256
	PKCS1WithSHA384:        #PKCS1WithSHA384
	PKCS1WithSHA512:        #PKCS1WithSHA512
	PSSWithSHA256:          #PSSWithSHA256
	PSSWithSHA384:          #PSSWithSHA384
	PSSWithSHA512:          #PSSWithSHA512
	ECDSAWithP256AndSHA256: #ECDSAWithP256AndSHA256
	ECDSAWithP384AndSHA384: #ECDSAWithP384AndSHA384
	ECDSAWithP521AndSHA512: #ECDSAWithP521AndSHA512
	Ed25519:                #Ed25519
	PKCS1WithSHA1:          #PKCS1WithSHA1
	ECDSAWithSHA1:          #ECDSAWithSHA1
}

// RSASSA-PKCS1-v1_5 algorithms.
#PKCS1WithSHA256: #SignatureScheme & 0x0401
#PKCS1WithSHA384: #SignatureScheme & 0x0501
#PKCS1WithSHA512: #SignatureScheme & 0x0601

// RSASSA-PSS algorithms with public key OID rsaEncryption.
#PSSWithSHA256: #SignatureScheme & 0x0804
#PSSWithSHA384: #SignatureScheme & 0x0805
#PSSWithSHA512: #SignatureScheme & 0x0806

// ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.
#ECDSAWithP256AndSHA256: #SignatureScheme & 0x0403
#ECDSAWithP384AndSHA384: #SignatureScheme & 0x0503
#ECDSAWithP521AndSHA512: #SignatureScheme & 0x0603

// EdDSA algorithms.
#Ed25519: #SignatureScheme & 0x0807

// Legacy signature and hash algorithms for TLS 1.2.
#PKCS1WithSHA1: #SignatureScheme & 0x0201
#ECDSAWithSHA1: #SignatureScheme & 0x0203

// ClientHelloInfo contains information from a ClientHello message in order to
// guide application logic in the GetCertificate and GetConfigForClient callbacks.
#ClientHelloInfo: {
	// CipherSuites lists the CipherSuites supported by the client (e.g.
	// TLS_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256).
	CipherSuites: [...uint16] @go(,[]uint16)

	// ServerName indicates the name of the server requested by the client
	// in order to support virtual hosting. ServerName is only set if the
	// client is using SNI (see RFC 4366, Section 3.1).
	ServerName: string

	// SupportedCurves lists the elliptic curves supported by the client.
	// SupportedCurves is set only if the Supported Elliptic Curves
	// Extension is being used (see RFC 4492, Section 5.1.1).
	SupportedCurves: [...#CurveID] @go(,[]CurveID)

	// SupportedPoints lists the point formats supported by the client.
	// SupportedPoints is set only if the Supported Point Formats Extension
	// is being used (see RFC 4492, Section 5.1.2).
	SupportedPoints: [...uint8] @go(,[]uint8)

	// SignatureSchemes lists the signature and hash schemes that the client
	// is willing to verify. SignatureSchemes is set only if the Signature
	// Algorithms Extension is being used (see RFC 5246, Section 7.4.1.4.1).
	SignatureSchemes: [...#SignatureScheme] @go(,[]SignatureScheme)

	// SupportedProtos lists the application protocols supported by the client.
	// SupportedProtos is set only if the Application-Layer Protocol
	// Negotiation Extension is being used (see RFC 7301, Section 3.1).
	//
	// Servers can select a protocol by setting Config.NextProtos in a
	// GetConfigForClient return value.
	SupportedProtos: [...string] @go(,[]string)

	// SupportedVersions lists the TLS versions supported by the client.
	// For TLS versions less than 1.3, this is extrapolated from the max
	// version advertised by the client, so values other than the greatest
	// might be rejected if used.
	SupportedVersions: [...uint16] @go(,[]uint16)

	// Conn is the underlying net.Conn for the connection. Do not read
	// from, or write to, this connection; that will cause the TLS
	// connection to fail.
	Conn: net.#Conn
}

// CertificateRequestInfo contains information from a server's
// CertificateRequest message, which is used to demand a certificate and proof
// of control from a client.
#CertificateRequestInfo: {
	// AcceptableCAs contains zero or more, DER-encoded, X.501
	// Distinguished Names. These are the names of root or intermediate CAs
	// that the server wishes the returned certificate to be signed by. An
	// empty slice indicates that the server has no preference.
	AcceptableCAs: [...bytes] @go(,[][]byte)

	// SignatureSchemes lists the signature schemes that the server is
	// willing to verify.
	SignatureSchemes: [...#SignatureScheme] @go(,[]SignatureScheme)

	// Version is the TLS version that was negotiated for this connection.
	Version: uint16
}

// RenegotiationSupport enumerates the different levels of support for TLS
// renegotiation. TLS renegotiation is the act of performing subsequent
// handshakes on a connection after the first. This significantly complicates
// the state machine and has been the source of numerous, subtle security
// issues. Initiating a renegotiation is not supported, but support for
// accepting renegotiation requests may be enabled.
//
// Even when enabled, the server may not change its identity between handshakes
// (i.e. the leaf certificate must be the same). Additionally, concurrent
// handshake and application data flow is not permitted so renegotiation can
// only be used with protocols that synchronise with the renegotiation, such as
// HTTPS.
//
// Renegotiation is not defined in TLS 1.3.
#RenegotiationSupport: int // #enumRenegotiationSupport

#enumRenegotiationSupport:
	#RenegotiateNever |
	#RenegotiateOnceAsClient |
	#RenegotiateFreelyAsClient

#values_RenegotiationSupport: {
	RenegotiateNever:          #RenegotiateNever
	RenegotiateOnceAsClient:   #RenegotiateOnceAsClient
	RenegotiateFreelyAsClient: #RenegotiateFreelyAsClient
}

// RenegotiateNever disables renegotiation.
#RenegotiateNever: #RenegotiationSupport & 0

// RenegotiateOnceAsClient allows a remote server to request
// renegotiation once per connection.
#RenegotiateOnceAsClient: #RenegotiationSupport & 1

// RenegotiateFreelyAsClient allows a remote server to repeatedly
// request renegotiation.
#RenegotiateFreelyAsClient: #RenegotiationSupport & 2

// A Config structure is used to configure a TLS client or server.
// After one has been passed to a TLS function it must not be
// modified. A Config may be reused; the tls package will also not
// modify it.
#Config: {
	// Rand provides the source of entropy for nonces and RSA blinding.
	// If Rand is nil, TLS uses the cryptographic random reader in package
	// crypto/rand.
	// The Reader must be safe for use by multiple goroutines.
	Rand: io.#Reader

	// Certificates contains one or more certificate chains to present to the
	// other side of the connection. The first certificate compatible with the
	// peer's requirements is selected automatically.
	//
	// Server configurations must set one of Certificates, GetCertificate or
	// GetConfigForClient. Clients doing client-authentication may set either
	// Certificates or GetClientCertificate.
	//
	// Note: if there are multiple Certificates, and they don't have the
	// optional field Leaf set, certificate selection will incur a significant
	// per-handshake performance cost.
	Certificates: [...#Certificate] @go(,[]Certificate)

	// NameToCertificate maps from a certificate name to an element of
	// Certificates. Note that a certificate name can be of the form
	// '*.example.com' and so doesn't have to be a domain name as such.
	//
	// Deprecated: NameToCertificate only allows associating a single
	// certificate with a given name. Leave this field nil to let the library
	// select the first compatible chain from Certificates.
	NameToCertificate: {[string]: null | #Certificate} @go(,map[string]*Certificate)

	// NextProtos is a list of supported application level protocols, in
	// order of preference. If both peers support ALPN, the selected
	// protocol will be one from this list, and the connection will fail
	// if there is no mutually supported protocol. If NextProtos is empty
	// or the peer doesn't support ALPN, the connection will succeed and
	// ConnectionState.NegotiatedProtocol will be empty.
	NextProtos: [...string] @go(,[]string)

	// ServerName is used to verify the hostname on the returned
	// certificates unless InsecureSkipVerify is given. It is also included
	// in the client's handshake to support virtual hosting unless it is
	// an IP address.
	ServerName: string

	// ClientAuth determines the server's policy for
	// TLS Client Authentication. The default is NoClientCert.
	ClientAuth: #ClientAuthType

	// InsecureSkipVerify controls whether a client verifies the server's
	// certificate chain and host name. If InsecureSkipVerify is true, crypto/tls
	// accepts any certificate presented by the server and any host name in that
	// certificate. In this mode, TLS is susceptible to machine-in-the-middle
	// attacks unless custom verification is used. This should be used only for
	// testing or in combination with VerifyConnection or VerifyPeerCertificate.
	InsecureSkipVerify: bool

	// CipherSuites is a list of enabled TLS 1.0–1.2 cipher suites. The order of
	// the list is ignored. Note that TLS 1.3 ciphersuites are not configurable.
	//
	// If CipherSuites is nil, a safe default list is used. The default cipher
	// suites might change over time.
	CipherSuites: [...uint16] @go(,[]uint16)

	// PreferServerCipherSuites is a legacy field and has no effect.
	//
	// It used to control whether the server would follow the client's or the
	// server's preference. Servers now select the best mutually supported
	// cipher suite based on logic that takes into account inferred client
	// hardware, server hardware, and security.
	//
	// Deprecated: PreferServerCipherSuites is ignored.
	PreferServerCipherSuites: bool

	// SessionTicketsDisabled may be set to true to disable session ticket and
	// PSK (resumption) support. Note that on clients, session ticket support is
	// also disabled if ClientSessionCache is nil.
	SessionTicketsDisabled: bool

	// SessionTicketKey is used by TLS servers to provide session resumption.
	// See RFC 5077 and the PSK mode of RFC 8446. If zero, it will be filled
	// with random data before the first server handshake.
	//
	// Deprecated: if this field is left at zero, session ticket keys will be
	// automatically rotated every day and dropped after seven days. For
	// customizing the rotation schedule or synchronizing servers that are
	// terminating connections for the same host, use SetSessionTicketKeys.
	SessionTicketKey: bytes @go(,[32]byte)

	// ClientSessionCache is a cache of ClientSessionState entries for TLS
	// session resumption. It is only used by clients.
	ClientSessionCache: #ClientSessionCache

	// MinVersion contains the minimum TLS version that is acceptable.
	//
	// By default, TLS 1.2 is currently used as the minimum when acting as a
	// client, and TLS 1.0 when acting as a server. TLS 1.0 is the minimum
	// supported by this package, both as a client and as a server.
	//
	// The client-side default can temporarily be reverted to TLS 1.0 by
	// including the value "x509sha1=1" in the GODEBUG environment variable.
	// Note that this option will be removed in Go 1.19 (but it will still be
	// possible to set this field to VersionTLS10 explicitly).
	MinVersion: uint16

	// MaxVersion contains the maximum TLS version that is acceptable.
	//
	// By default, the maximum version supported by this package is used,
	// which is currently TLS 1.3.
	MaxVersion: uint16

	// CurvePreferences contains the elliptic curves that will be used in
	// an ECDHE handshake, in preference order. If empty, the default will
	// be used. The client will use the first preference as the type for
	// its key share in TLS 1.3. This may change in the future.
	CurvePreferences: [...#CurveID] @go(,[]CurveID)

	// DynamicRecordSizingDisabled disables adaptive sizing of TLS records.
	// When true, the largest possible TLS record size is always used. When
	// false, the size of TLS records may be adjusted in an attempt to
	// improve latency.
	DynamicRecordSizingDisabled: bool

	// Renegotiation controls what types of renegotiation are supported.
	// The default, none, is correct for the vast majority of applications.
	Renegotiation: #RenegotiationSupport

	// KeyLogWriter optionally specifies a destination for TLS master secrets
	// in NSS key log format that can be used to allow external programs
	// such as Wireshark to decrypt TLS connections.
	// See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.
	// Use of KeyLogWriter compromises security and should only be
	// used for debugging.
	KeyLogWriter: io.#Writer
}

// ticketKeyNameLen is the number of bytes of identifier that is prepended to
// an encrypted session ticket in order to identify the key used to encrypt it.
_#ticketKeyNameLen: 16

// ticketKeyLifetime is how long a ticket key remains valid and can be used to
// resume a client connection.
_#ticketKeyLifetime: time.#Duration & 604800000000000

// ticketKeyRotation is how often the server should rotate the session ticket key
// that is used for new tickets.
_#ticketKeyRotation: time.#Duration & 86400000000000

_#maxSessionTicketLifetime: time.#Duration & 604800000000000

_#roleClient: true

_#roleServer: false

_#keyLogLabelTLS12:           "CLIENT_RANDOM"
_#keyLogLabelClientHandshake: "CLIENT_HANDSHAKE_TRAFFIC_SECRET"
_#keyLogLabelServerHandshake: "SERVER_HANDSHAKE_TRAFFIC_SECRET"
_#keyLogLabelClientTraffic:   "CLIENT_TRAFFIC_SECRET_0"
_#keyLogLabelServerTraffic:   "SERVER_TRAFFIC_SECRET_0"

// A Certificate is a chain of one or more certificates, leaf first.
#Certificate: {
	Certificate: [...bytes] @go(,[][]byte)

	// PrivateKey contains the private key corresponding to the public key in
	// Leaf. This must implement crypto.Signer with an RSA, ECDSA or Ed25519 PublicKey.
	// For a server up to TLS 1.2, it can also implement crypto.Decrypter with
	// an RSA PublicKey.
	PrivateKey: crypto.#PrivateKey

	// SupportedSignatureAlgorithms is an optional list restricting what
	// signature algorithms the PrivateKey can be used for.
	SupportedSignatureAlgorithms: [...#SignatureScheme] @go(,[]SignatureScheme)

	// OCSPStaple contains an optional OCSP response which will be served
	// to clients that request it.
	OCSPStaple: bytes @go(,[]byte)

	// SignedCertificateTimestamps contains an optional list of Signed
	// Certificate Timestamps which will be served to clients that request it.
	SignedCertificateTimestamps: [...bytes] @go(,[][]byte)

	// Leaf is the parsed form of the leaf certificate, which may be initialized
	// using x509.ParseCertificate to reduce per-handshake processing. If nil,
	// the leaf certificate will be parsed as needed.
	Leaf?: null | x509.#Certificate @go(,*x509.Certificate)
}

_#handshakeMessage: _

// CertificateVerificationError is returned when certificate verification fails during the handshake.
#CertificateVerificationError: {
	// UnverifiedCertificates and its contents should not be modified.
	UnverifiedCertificates: [...null | x509.#Certificate] @go(,[]*x509.Certificate)
	Err: _ @go(,error)
}
